[["index.html", "Chapter 1 Introduction 1.1 Abstract 1.2 Learning objectives 1.3 Prerequisites 1.4 License", " Collaborative Coding for Scientific Research: Git, GitHub, and open science Pat Bills &amp; Kelly Kapsar Last edited: 2024-04-14 Chapter 1 Introduction 1.1 Abstract This is a guide to open/team science projects on GitHub. This is not an introduction to git but a follow-on to such an introduction. While there are many introductory tutorials out there, we have found that there is a lack of information on the “culture” of open science using git/GitHub. People discover others’ code/projects, but don’t quite understand how they are organized or how to bring up and problems they’ve encountered or suggested changes that they have. This workshop is designed to empower attendees to actively participate in and engage with the open science community by teaching the often overlooked norms and procedures for understanding and working with others’ code projects. 1.2 Learning objectives By completing this workshop, participants will be able to: 1. Explore and understand the organization of a research project or package (Anatomy of well-organized GitHub repositories) 2. Use others’ code in your own workflows 3. Engage with the owners/maintainers and the broader coding community to identify and participate in discussion of issues 1.3 Prerequisites Coding: Be comfortable with coding in a language like R and/or Python. In other words: You should be familiar with reading/writing and basic wrangling of files or dataframes. Resources: Tidying data in R (Ch. in Data Science with R by Garrett Grolemund) Tidying data in Python (Ch. in Python for Data Science by Turrell et al.) Git: Have used Git to track changes in your code, OR have completed the introduction to the “git” distributed version control system on the Software Carpentries website, and understand the terms: git add/staging, commits, commit message, git history, git remote, push, pull. Resources: Version control with git (Software Carpentries) GitHub: Have at least minimal experience with github and ideally have a project with some of your code there. In other words: If you have no experience with Github, then, prior to the workshop using resources below, please create an account and attempt to push/pull changes to it. If you have attended a previous workshop covering these tasks, then that is sufficient. Resources: Version control with git and GitHub - general intro and RStudio set-up (NSF Arctic Data Center) Integrating git and GitHub with VS Code for Python users (VS Code tutorial) Open Science: Desire to become more of an active participant in the open science community. In other words: Be curious about using others’ code and writing code that others can use. 1.4 License This work is licensed under Attribution-ShareAlike 4.0 International "],["git-review.html", "Chapter 2 Review: Principles of Git 2.1 Distributed version control 2.2 Why use Git? 2.3 Why use GitHub? 2.4 Alternatives to GitHub 2.5 Git/GitHub workflow: 2.6 Branching with git 2.7 Collaborative coding: Forking and pull requests", " Chapter 2 Review: Principles of Git Figure 2.1: Source: Allsion Horst 2.1 Distributed version control Version control systems are an answer to the age-old problem of “script_final.R”, “script_submitted_to_Science.R”, “script_finaler.R”, and “script_final_i_swear_this_is_the_last_one.R” that tend to clog up and confuse storage space on all of our computers. By tracking changes in a document (in this context, usually a coded script), version control systems allow you to keep a record of all the changes that you have made without having to re-save new documents every time. Version control systems also allow for multiple users to make changes to the same document and keep track of the who-did-what side of things. Version control systems store all of these changes and iterations in what’s called a “repository” (also known as a repo). Think of the repository as the archive that keeps track of all of the changes that you’ve made to your work over time. Typically a single repository is created for each unique project, program, package, etc. In the context of scientific research, a new repository is often created to store the code needed for the analyses in an individual manuscript. This way, the repository can be referenced in a publication and readers of your work can look “under-the-hood” of the methods you used. This approach increases the transparency and accuracy of research by allowing others to reproduce your results and identify and possible mistakes. There are two main types of version control systems: centralized and distributed. The difference lies in where the repository is stored. In a centralized version control system, there is a single computer server that hosts the repository. All the people editing to the repository must have access to that server. The downside of centralized version control is that if the server crashes or gets corrupted or decides to take a vacation, your team is in big trouble. In other words, there is little redundancy in a centralized version control system. Distributed version control systems, on the other hand, allow all the contributors create a “clone” of the repository that they store on their own computer. They can make changes to this local repository and, if they want to share those changes with others, they can “push” them up to a shared repository, often stored in an online-based repository hosting system (see Why use Github? below). In this way, if the cloud based repository decides to up and explode for some unknown reason (or a known reason), there are multiple backup versions on contributor’s local computers that can be used to restore the repo. Figure 2.2: Source: geeksforgeeks.org 2.2 Why use Git? Coding has become a nearly ubiquitous part of scientific research, with scientists developing increasingly complex analyses requiring extensive data wrangling and post-analysis processing and visualization steps. The development of the code needed to run these analyses often goes through many iterations during the initial development process through to the final stages of peer review. Using a distributed version control system like Git can help researchers to code collaboratively, manage and organize different versions of the same analysis, and serve as an archive of the methods used to process and analyze research data. These advantages help to support researchers in the pursuit of “open science” by increasing transparency while also serving as a useful record that can be referred back to and reproduced in the future. If you’re looking for more information on Git, check out Happy Git and GitHub for the useR. 2.3 Why use GitHub? GitHub is an online-based repository hosting system for Git repositories. It’s worth noting that GitHub is not the only hosting system for Git repositories (see Alternatives below), however it is the most popular system and is nearly ubiquitous in the sciences. Additionally, GitHub has many useful features that expand upon Git and facilitate communication and collaboration amongst large groups of coders.GitHub “Issues” are one such feature that allow users to identify problems or ways to improve a set of code, to assign responsibility for the tasks needed to address them, and to keep track of the changes in the code that were made. Additionally, GitHub has features that allow for content generation, including static websites (like this one!) created using GitHub Pages. While GitHub can require a bit of a learning curve, we believe that it is well worth the effort and, in the long run, will save researchers a lot of time on trouble-shooting, reproducing results, and sharing analysis. 2.4 Alternatives to GitHub GitLab Bitbucket 2.5 Git/GitHub workflow: This is an extremely simplified description of the components of a Git workflow. If you’d like to get more into the weeds, we highly recommend Pro Git, Chapter 2.2. Cloning: Cloning is the term used for the initial creation of a local copy of a remote repository on your computer. A typical workflow is to clone the repository, modify the code, stage the changes, commit the staged changes, and then push the changes back up to the remote repository. Staging: After you’ve modified a document, staging allows you to mark the file for inclusion in a future commit. If your terminal is set to the home directory of your repository, the command git add &lt;filename&gt; will allow you to stage changes. Committing: Once a change or group of changes is staged, they can be committed to your local repository. A commit is a way to group a set of changes together under a common theme. Part of the commit is a commit message which allows you to summarize the purpose of the changes you made to the code. More on the anatomy of a good commit message later. Note: You can pick and choose the staged files that you want to be included in each commit. Pushing/Pulling: Pushing a commit is the way to incorporate changes from your local repository up to the remote repository. Think of it as pushing your changes up from your computer into the cloud. Conversely, pulling changes is taking changes that others have made to the remote repository and pulling them down from the cloud onto your local version of the repo. 2.6 Branching with git Unlike cloning or forking, you can think of branches as a kind of internal copy within your repository. When working on a branch, the files in the main repository are untouched. You can stage changes, make commits, and push/pull to remote within a branch and it won’t affect the main repository. This makes branches very useful when you want to make substantial changes to your repository that you’re not quite sure will work. Branches are also helpful when collaborating with others. If one person needs to run the main model, but you want to test out tweaking a few things, you can work on a branch while they stay on the main branch. Then, once your confident the changes in your branch are working correctly you can merge them from your branch back into the main repo. 2.7 Collaborative coding: Forking and pull requests Figure 2.3: https://toolsqa.com/git/difference-between-git-clone-and-git-fork/ When working on large open source project, it’s a good idea to not let anybody have immediate edit access to the repository where that project is kept. However, you still want to allow the broader user community to participate and contribute to the project. Forking is one way to address this problem. Forking a repository allows you to create a copy of a given repository on your personal GitHub account. When you make changes to a forked repository, the original repository is not affected. However, if you have some changes that you think would help to improve the original project, you can submit a pull request to the owners of the original repository. If they like your change, then they can accept and incorporate it into the original project’s repository. Still confused? This webpage has a really nice explanation of forking vs. cloning, along with helpful diagrams. "],["repo-organization.html", "Chapter 3 Anatomy of a GitHub repository 3.1 Types of repositories: 3.2 Implications of repository type for re-use 3.3 Directory structures 3.4 Dependencies/requirements 3.5 Interaction of source scripts 3.6 Package vs project structures 3.7 Finding branches in GitHub 3.8 Versioning and releases 3.9 Forks", " Chapter 3 Anatomy of a GitHub repository 3.1 Types of repositories: Package (installable) Project (useable) Reference (readable) 3.2 Implications of repository type for re-use 3.3 Directory structures What to look for when using someone else’s code 3.4 Dependencies/requirements 3.5 Interaction of source scripts (R and python) 3.6 Package vs project structures 3.7 Finding branches in GitHub Where to find and look at branches in GitHub 3.8 Versioning and releases 3.9 Forks "],["collaborating.html", "Chapter 4 Collaborating with GitHub 4.1 Understanding commits 4.2 Project management with GitHub 4.3 Issue management 4.4 Communication using issues 4.5 Engaging with the community 4.6 Github link awesomeness", " Chapter 4 Collaborating with GitHub 4.1 Understanding commits 4.1.1 How people communicate using commit messages Perspective of commit messages as communication can change what you include in a commit (independent of github) 4.2 Project management with GitHub Using Github’s project management lite features 4.3 Issue management What is issue management? Following issues and their fixes can help you track down your bugs 4.3.1 Pandas Example: My commit Found someone else that had the same problem Found this in the source-code for the documentation This is mentioned in the release notes for verion 1.5.0 The release notes have a link to the issue(s) for every change, including this one GH9568 , which spells out why the change was made. Since I didn’t even need to specify this parameter (it was using the default value!) I just removed it from my code, and learned my lesson to keep my code as simple as possible so that I don’t get burned by changes into the packages I depend upon. 4.4 Communication using issues 4.4.1 Requesting help/features or reporting bugs (using reprexes). 4.4.2 Example: How ask package maintainers to accommodate the global dateline and very high latitudes https://github.com/rstudio/leaflet/issues/495 This is a great example of an obtuse issue. There is an R package “MapView” this is a 1-stop-mapping thing, super easy. Someone there raised an issue. MapView depends on RLeaflet (I just know this, it doesn’t say that anywhere in the issue). The leader of the MapView project realized that it was an RLeaflet problem, so copy/pasted the issue into the RLeaflet project. I say RLeaflet because that project actually heavily depends on the original leaflet.js for javascript, which most people just called “leaflet”. Another interesting thing is that the first commenter (Darcy somebody) says that polygons are fine, which does not need to be said because the OP already said it was ok, but no one piled on and said “he already said that.” Note the issue was raised in 2015 and no one was assigned and it was not fixed. The issue was reference in 2018 for new issue (created by Rstudio) to fix it, and I only know that because in the new issue they referenced the issue number. but even that one was not fixed. also in the original issue is an extensive post to show a work-around. That info now just =sits here in a github issue. A question for the group: what should have been done by the project to deal with this issue (hints, create an issue to add the work-around in the documentation, when creating a new issue, close the original and reference the new one.. possibly tag it as “wontfix” or better tag it in a project roadmap to make it clear they care about it and will deal with at some future time. https://github.com/rstudio/leaflet/issues/225 4.4.3 Example: ggmap package Issue with Pacific mapping with ggmap: https://github.com/dkahle/ggmap/issues/326 * (solution is to change the projection, the software is not the problem, but is it in the docs?) * Another person had a question/problem but it was totally ignored: https://github.com/dkahle/ggmap/issues/295 + Why is that? + Is there a document for this package describing how to participate in the community? + Are the volunteers following the lead of the owner? + Who is fine ignoring these? 4.5 Engaging with the community Engaging with owners/maintainers and the broader coding community to identify and participate in discussion of issues. 4.5.1 What is a ‘pull request?’ (PR) (hint: it’s a github thing) A PR lifecycle: Issue Fork/Branch PR Merge 4.6 Github link awesomeness Permalinks in code and issues References to issues from commits and referencing to commits from comments "],["documentation.html", "Chapter 5 Finding and using documentation 5.1 Important elements to look out for 5.2 Code as documentation 5.3 Issues, commits and MR as documentation", " Chapter 5 Finding and using documentation 5.1 Important elements to look out for 5.2 Code as documentation 5.3 Issues, commits and MR as documentation "],["licensing.html", "Chapter 6 Attribution and licensing", " Chapter 6 Attribution and licensing "],["workflows.html", "Chapter 7 GitHub workflows 7.1 Continuous Integration/Continuous Delivery (CI/CD) and github “workflows”", " Chapter 7 GitHub workflows 7.1 Continuous Integration/Continuous Delivery (CI/CD) and github “workflows” 7.1.1 What is it? 7.1.2 Benefits 7.1.3 GitHub workflows "],["exercise.html", "Chapter 8 Exercise: Working with a repo 8.1 Instructions:", " Chapter 8 Exercise: Working with a repo Cloning a repository and using the code therein to get a result 8.1 Instructions: Select a repository from 3 choices: Python, R, Markdown Clone, follow instructions to get it working. Is there a minimum example? Can you run the tests? What is the version, release? What’s new based on the change log? Find an issue that needs to be fixed. What would you do to fix it? "],["glossary.html", "Chapter 9 Glossary", " Chapter 9 Glossary 9.0.1 Branch: An independent development stream within a repository where you can develop new features independently without the fear of interrupting others’ workflows. See this book chapter for more info. 9.0.2 Commit: A labelled set of changes to the code. A single commit an include changes to one or multiple files. 9.0.3 Commit hash: A nickname for the 40 character git commit SHA-1 checksum value which represents a unique ID given to each commit in a git repo. Commit hashes are also often presented in their shortened 8-character form. 9.0.4 Changeset: Another name for the set of changes in a particular commit. 9.0.5 Git flow: A strategy for organizing branches within a repository. Typically includes 5 branch types: Main, Develop, Feature, Release, and Hotfix. See this nice cheatsheet or this explanation for more info. 9.0.6 Git log graph: Also called a source tree or “graph”, git log graphs are a visual representation of the structure of a repository (e.g., branches and commits) generated using the commits git log --graph. A lot of software also has built-in git log graphs. 9.0.7 GitHub flavored-markdown (GFM): GitHub’s version of the markdown syntax, which contains some additional functionality. See this great overview in GitHub’s Documentation for more info. 9.0.8 Issue: A feature of GitHub that allows users to identify problems/bugs, keep track of tasks, receive feedback on changes, etc. See GitHub’s documentation section on Issues for more details. 9.0.9 Markdown: A text-encoding system that allows you to format plain text and make it fancy (e.g., bold, italics). Markdown file extensions are “.md”. The text of this book is written in markdown - if you want to check out some of the .rmd files (short for R Markdown), follow this link. 9.0.10 Pull request (PR): A way to “request” that the maintainers of a repository (sometimes you or sometimes somebody else) “pull” a set of changes that you’ve proposed into another branch. Pull requests can be used to merge changes from one branch to another within a single repository (see here for more details) or between a forked version of a repository (e.g., one that you don’t have write access to) and a branch in the original repository (see here for more info). 9.0.11 Repository (Repo): A collection of files that Git keeps track of. 9.0.12 Remote: The copy of the repository that is hosted on the internet or another serve (i.e., not the “local” version on your computer). 9.0.13 Squashed commits: A way to effectively combine multiple previous commits into one new commit. (Note: technically the previous commits are not deleted, but for all intents and purposes you’ve now “squashed” them into one new commit.) Squashed commits can be very helpful when working on a branch that you want to then pull request to merge back into another branch. "],["resources.html", "Chapter 10 Resources 10.1 Data Wrangling 10.2 Data Processing 10.3 Git/GitHub and Version Control", " Chapter 10 Resources Eager to dive deeper into collaborative coding? Here are some more great resources that delve into specific areas we’ve overviewed during this workshop. 10.1 Data Wrangling Data Cleaning and Quality Control (Environmental Data Initiative): A great overview of best practices in organizing data sets, arranging data tables, and defining levels of data processing (Note: Focus on environmental data, but principles apply to any discipline). Metadata and the Ecological Metadata Language (Environmental Data Initiative): Introduction to Ecological Metadata Language with tools for creating EML-formatted metadata (Note: Focus on environmental data). 10.2 Data Processing Data pipelining in R using the Targets package (Targets for Ecologists): A step-by-step walkthrough guide for using the data pipelining tool “Targets” in the R programming language. Data pipelining is a great way to ensure reproducibility and speed up the generation of results by setting up the computer to keep track of all the steps in your analysis and re-running only those that are alterred when you make a change to the code. R doParallel: How to Parallelize R DataFrame Computations (Radečić 2024): Overview of the doParallel package in R and its ability to speed up data analyses by running in chunks of data in parallel. Implementing GitHub Actions continuous integration to reduce error rates in ecological data collection (Kim et al. 2022) 10.3 Git/GitHub and Version Control Learn git branching interactively: A fun walk-through to learn basic git commands, including working on branches. Also includes some more advanced git techniques. Not just for programmers: How GitHub can accelerate collaborative and reproducible research in ecology and evolution (Braga et al. 2023) Excuse Me, Do You Have a Moment to Talk About Version Control? (Bryan 2018): (Note: Full text available with MSU login) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
