[["index.html", "Chapter 1 Introduction 1.1 Abstract 1.2 Learning objectives 1.3 Prerequisites 1.4 License", " Collaborative Coding for Scientific Research: Git, GitHub, and open science Pat Bills &amp; Kelly Kapsar Last edited: 2024-04-16 Chapter 1 Introduction 1.1 Abstract This book is designed as a guide to open/team science projects on GitHub. This is not an introduction to git but a follow-on to such an introduction. While there are many introductory tutorials on git commands and such out there (see the Software Carpentries git workshop for a great example), we have found that there is a lack of information on the “culture” of open science using git/GitHub. People discover others’ code/projects, but don’t quite understand how they are organized or how to bring up and problems they’ve encountered or suggested changes that they have. This workshop is designed to empower attendees to actively participate in and engage with the open science community by teaching the often overlooked norms and procedures for understanding and working with others’ code projects. 1.2 Learning objectives By completing this workshop, participants will be able to: Engage with the owners/maintainers and the broader coding community to identify and participate in discussion of issues Explore and understand the organization of a research project or package (Anatomy of well-organized GitHub repositories) Use others’ code in your own workflows 1.3 Prerequisites Coding: Be comfortable with coding in a language like R and/or Python. In other words: You should be familiar with reading/writing and basic wrangling of files or dataframes. Resources: Tidying data in R (Ch. in Data Science with R by Garrett Grolemund) Tidying data in Python (Ch. in Python for Data Science by Turrell et al.) Git: Have used Git to track changes in your code, OR have completed the introduction to the “git” distributed version control system on the Software Carpentries website, and understand the terms: git add/staging, commits, commit message, git history, git remote, push, pull. Resources: Version control with git (Software Carpentries) GitHub: Have at least minimal experience with github and ideally have a project with some of your code there. In other words: If you have no experience with Github, then, prior to the workshop using resources below, please create an account and attempt to push/pull changes to it. If you have attended a previous workshop covering these tasks, then that is sufficient. Resources: Version control with git and GitHub - general intro and RStudio set-up (NSF Arctic Data Center) Integrating git and GitHub with VS Code for Python users (VS Code tutorial) Open Science: Desire to become more of an active participant in the open science community. In other words: Be curious about using others’ code and writing code that others can use. 1.4 License This work is licensed under Attribution-ShareAlike 4.0 International "],["GitHub-in-practice.html", "Chapter 2 Git and GitHub In Practice 2.1 What is a code base? 2.2 Code vs Git vs GitHub 2.3 Review: Principles of Git 2.4 Git vs. GitHub 2.5 How people communicate using commit messages 2.6 GitHub issue tracking 2.7 Practical git collab using branches 2.8 Collaborative coding: Forking and pull requests 2.9 Example of real-world detective work using GitHub", " Chapter 2 Git and GitHub In Practice This chapter will provide an orientation to open science code repositories, via GitHub, so you can find and use code that may be useful to you. We learned to organize and work through our own projects by observing how others organize theirs. The amazing thing is that you can find hundreds of excellent examples to learn from as even major companies put their code on GitHub. 2.1 What is a code base? In this book we may use the terms “repository”, “proejct”, or “code base” interchangeably but they have slightly different meanings: “Code base” is a colloquial term for any collection of related to code in one or more files that works together to perform a function, or provide an application. A “repository” is an collection of code managed by git, not necessarily on an external server (i.e., GitHub or others). This could be on your laptop. The database of version history is inside the .git folder, and so that .git folder is the repository (although when people say “repository” or “repo” they are often referring to the combination of the code base and the .git version control). This is also called a “git repo”. GitHub also calls their units “repositories”, so in GitHub the URL pattern github.com/&lt;user_name&gt;/&lt;repository_name&gt; contains a git repository (and possibly more than one). We may think of projects as the code base plus associated data files, and all of the other stuff needed to complete the research. However, it should be noted that GitHub uses “project” to mean “project management features” (task tracking, due dates, work progress monitoring) which can be used for one or more repos. A research project may require multiple repos (e.g., one for data entry &amp; cleaning, one for analysis, and one for a website to show it all off) and a GitHub project can tie those together. This is a new feature that we won’t go into much but we will go into the existing project management features that GitHub has for repos (e.g., issue tracking). 2.2 Code vs Git vs GitHub Think of these systems as a hierarchy, building up each other: code : files (e.g., a zip file you send to someone) git repository: managed repository of code files with version control tracking GitHub: hosting service for git repositories with enhanced collaboration, communication and project management based on git The heart of all of this is the code, and when one is trying to learn git and GitHub as they present it, it appears that GitHub owns the code, but it’s just a service. Code is money and GitHub is just the bank. 2.3 Review: Principles of Git Figure 2.1: Source: Allsion Horst 2.3.1 Distributed version control Version control systems are an answer to the age-old problem of “script_final.R”, “script_submitted_to_Science.R”, “script_finaler.R”, and “script_final_i_swear_this_is_the_last_one.R” that tend to clog up and confuse storage space on all of our computers. By tracking changes in a document (in this context, usually a coded script), version control systems allow you to keep a record of all the changes that you have made without having to re-save new documents every time. Version control systems also allow for multiple users to make changes to the same document and keep track of the who-did-what side of things. Version control systems store all of these changes and iterations in what’s called a “repository” (also known as a repo). Think of the repository as the archive that keeps track of all of the changes that you’ve made to your work over time. Typically a single repository is created for each unique project, program, package, etc. In the context of scientific research, a new repository is often created to store the code needed for the analyses in an individual manuscript. This way, the repository can be referenced in a publication and readers of your work can look “under-the-hood” of the methods you used. This approach increases the transparency and accuracy of research by allowing others to reproduce your results and identify and possible mistakes. There are two main types of version control systems: centralized and distributed. The difference lies in where the repository is stored. In a centralized version control system, there is a single computer server that hosts the repository. All the people editing the repository must have access to that server. The downside of centralized version control is that if the server crashes or gets corrupted or decides to take a vacation, your team is in big trouble. In other words, there is little redundancy in a centralized version control system. Distributed version control systems, on the other hand, allow all the contributors create a “clone” of the repository that they store on their own computer. They can make changes to this local repository and, if they want to share those changes with others, they can “push” them up to a shared repository, often stored in an online-based repository hosting system (see Why use GitHub? below). In this way, if the cloud based repository decides to up and explode for some unknown reason (or a known reason), there are multiple backup versions on contributor’s local computers that can be used to restore the repo. Figure 2.2: Source: geeksforgeeks.org 2.3.2 Why use Git? Coding has become a nearly ubiquitous part of scientific research, with scientists developing increasingly complex analyses requiring extensive data wrangling and post-analysis processing and visualization steps. The development of the code needed to run these analyses often goes through many iterations during the initial development process through to the final stages of peer review. Using a distributed version control system like Git can help researchers to code collaboratively, manage and organize different versions of the same analysis, and serve as an archive of the methods used to process and analyze research data. These advantages help to support researchers in the pursuit of “open science” by increasing transparency while also serving as a useful record that can be referred back to and reproduced in the future. If you’re looking for more information on Git, check out Happy Git and GitHub for the useR. 2.3.3 Git typical workflow (review) This is an extremely simplified description of the components of a basic git workflow, typically covered in introductory git books and workshops. For much more detail see: Pro Git, Chapter 2.2. Getting Started with Git from GitHub Software Carpentry Git for Novices workshop Cloning: First get a copy of an existing repository to work on. Cloning is the term used for downloading of a local copy of a remote repository on your computer. This includes all the branches and all of the history of repository. A typical workflow is to clone the repository, modify the code, stage the changes, commit the staged changes, and then push the changes back up to the remote repository. This requires access to, and knowing the URL of, a git remote. Editing: Edit your code on your computer to fix a bug or work on an new feature. Staging: After you’ve modified a document, staging allows you to mark the file for inclusion in a future commit. If your terminal is set to the home directory of your repository, the command git add &lt;filename&gt; will allow you to stage changes. Committing: Once a change or group of changes is staged, they can be committed to your local repository. A commit is a way to group a set of changes together under a common theme. Part of the commit is a commit message which allows you to summarize the purpose of the changes you made to the code. More on the anatomy of a good commit message later. Note: You can pick and choose the staged files that you want to be included in each commit. Pushing/Pulling: Pushing a commit is the way to incorporate changes from your local repository up to the remote repository. Think of it as pushing your changes up from your computer into the cloud. Conversely, pulling changes is taking changes that others have made to the remote repository and pulling them down from the cloud onto your local version of the repo. 2.3.4 Why use GitHub? As we will see below, GitHub has many useful features that expand upon git and facilitate communication and collaboration among large groups of coders. Additionally, GitHub has features that allow for content generation, including static websites (like this one!) created using GitHub Pages. While GitHub can require a bit of a learning curve, we believe that it is well worth the effort and, in the long run, will save researchers a lot of time on trouble-shooting, reproducing results, and sharing analysis. 2.3.5 Alternatives to GitHub It’s worth noting that GitHub is not the only hosting system for Git repositories (see Alternatives below), however it is the most popular system and is nearly ubiquitous in the sciences. GitLab Bitbucket 2.4 Git vs. GitHub Even experienced coders are unsure of the boundary between git and GitHub. The following table attempts to clarify which concept and feature are part of the git system and can be used independently from GitHub. GitHub is the most widely used ‘remote’ git server as it offers great collaboration features. Feature originally of Git Feature of GitHub Service Git does not have way to track problems and to-do items. issue tracking and other project management features are not connected to git, but GitHub helps to integration project management with git. commit: Track code changes and add a message describing this change (see reading commits). Collaborators can add comments on commits beyond the commitGitHub issues can be cross-referenced in commit messages. diff: Show the difference in two change sets. Can use command line, programming editor (Rstudio, VSCode, Eclipse, etc), or a specialized desktop application (MergeTool from Apple). Comments directly in code changes per line and create/share perma-links per line for feedback from collaborators. branch: Git tracks these code versions for you and can provide lists using git status, git branch -a, etc.Many programming editors have a feature to visualize the tree/graph of branches. GitHub allows you to easily show and switch between branches to compare without having to ‘checkout’ in your current director and initiate a merge from there. merge: Combine changes from one branch to another using several different methods, alert when there are conflicts and resolve conflicts. Can add a merge commit message to communicate. GitHub has an interface for merging directly on the website to help you preview what will happen without affecting your local repository, or the main branch. Fork: A copy of a repository that someone has decided to work on independently. In git, the repo that you forked from is called the ‘upstream’ repository. GitHub has a button to fork a repository into your own account, and keeps track of where that fork comes from, and which GitHub also called the ‘upstream’ repository. remote: Git was designed to share, and so the original ‘git’ program has a feature built in to act as server from which you can clone (download) a repo, push (up) changes, pull (down) others changes into your code. An external git server is a ‘remote.’ However the ‘git server’ requires the command line to run and has no web interface built in. At it’s core, GitHub is a git server and provides a URL from which to clone, push or pull to repos. Unlike git, GitHub can do this using WWW protocols and websites. There are other systems that provide the same ‘remote’ service as GitHub. “pull request”: A process invented by GitHub (and others) to facilitate accepting code from external collaborators. Additionally, it fosters communication among collaborators, giving them the ability to comment on code, contact reviewers, and connect to an issue tracking system. This perhaps is the core feature of GitHub. Note that other git servers use different terms. For example, git servers at gitlab.com calls them ‘merge requests’ “issue”: Issue tracking is not unique to git workflows, but general project management practice. GitHub has ‘lite’ project management features that integrate with git and code. 2.4.1 Other Resources for this section Tracking Changes from Software Carpentry’s “Version Control with Git” GitHub’s git guide to commits How to Level Up Your Git Commit Messages from the ‘free code camp’ 2.5 How people communicate using commit messages Reading through git commits is one of the best ways to learn about a code base. GitHub is an excellent system for reviewing the history of project via it’s commits. Commits What are the features of git (independent of GitHub) to use commit messages as communication? This is always covered in an introductory git course, but we summarize them here from the perspective of a communication system: The set of changes to the code. When we compare these changes to another version of the code, this is known as the “diff” (named for the utility that shows the changes). The commit message itself. Option additional summary message. Other things not directly part of the commit that put the commit in context: the branch it’s in, the fork it’s a part of, and a link to a description of the feature or issue (more on all of those things later). 2.5.1 Guidelines for using commits The central feature of most version control system is the “commit” we describe above. nd version control, at it’s heart, is a system for software developers to communicate. Understanding the motivation and context of the ‘git commit’ is key to interpreting a code repository. A git commit and the associate message should communicate: Why are these lines of code here? What feature does this bit of code help to implement, or which bug was fixed? What other code was changed, if any? Who made this change so I can ask them for more information if I need to (e.g., to debug or make changes to improve the code base)? To a limited extent, why is the code structured this way? (Although this is more often described in the code itself.) If my program incorporates, imports, or otherwise depends on this code, is it affected by this change? That is, I depend on this code base and something has changed that makes my system crash. We believe that approaching commits as communication will drive how you use git, and also help you to collaborate with GitHub. These are some guidelines that software developers adhere to for using git commit: Keep the commit focused on a very specific problem to fix or feature to add. Note that features often require many small adjustments or changes and so a feature implementation in code can be a collection of commits. Some use the phrase “atomic” to describe the changes you make: the smallest amount of change to make a difference, no less and no more. Code should still work when committing. That is, don’t commit non-working code unless you absolutely have to. The git commit message should focus on “why” instead of “what”: the code diff already shows us the what. Some things to emphasize: A good commit is focused on solving a single problem or making a change that helps to implement a small feature. This way it’s very clear was code was changed or added and why. When we you look over all the changes in a commit, it will be hard to to get a holistic understanding if it includes many changes lines across many files. Exploring git commit logs in GitHub will help you to understand how to use git more effectively. Less is more when it comes to commits. It takes discipline to make the commits completely atomic. We often think a change is complete, only to find a typo or other problem after the commit is made. Git has mechanisms for dealing with that we will define later. Git+GitHub is not a backup system. If you want to save all the work you’ve done use a real file back-up system, not git. Mac and Windows both have backup systems built-in, and you should use them to make as frequent snapshots or backups as possible. You could also have a copy of your code folder on an external drive. What if you are given a large set of changes that only halfway implements a bug fix or feature? Would you understand what do to next? That is one reason why commits should be as complete as possible. Sometimes because of how teams agree to work, you may be encouraged to push all of your code so it can be reviewed, even if you are not finished.In that case, devs (aka the coders) often put the acronym “WIP” for “Work in Progress” to indicate the code is not complete, or “untested” to indicate the code is complete but has not been rigorously tested. 2.5.2 Examples of ineffective commits: A change to a few lines in the readme for grammar or other minor edit, with the message “update readme” - this doesn’t say why the README was updated! A commit that says “daily commit” or “end-of-day commit” tells me nothing about why the code was changed, or how I should start up to complete it if I’m asked. Again, this appears to be an attempt to use git+GitHub as a backup system. Don’t do that. git commit message “fix” – fix what?…and why? 2.5.3 Effective Commits Effective commits can be 1 line of code or hundreds, it really depends on the context and what is being communicated. One example of a common problem in coding is the ‘boundary error’ or the related ‘off by one’ error. For example, if you are checking if a loop is done for a counter that is reduced each time, and you have counter==0 but some how the counter can be negative in some cases, the loop will continue! The solution is to change your if condition to counter &lt; 1 and a good commit message would “fix boundary error in replication loop”. You don’t need to mention the file name - that will be in the diff. 2.5.4 Real-world commit work-flow Being disciplined for commits is not easy and the authors frequently don’t follow this. Here is an example of a real-world, imperfect workflow: Adding a feature “add logistic regression analysis” Add code to accomplish this (and data files, parameters, etc) Quick testing show that is works! Add changed files and commit “add log regression for X,Y, Z…” Test again and find there is a problem! Fix the code, and test again Git add the files and commit “fix missing parameter for logistic regression analysis” (or something like that) Now we have two commits (and hence two diff views) that address different parts of a problem. Git has some great features for dealing with this that we will cover, and that will make you understand how others get their commit histories to look so clean and perfect! One major solution is to use branching, which we described in detail below. Branching is like telling the sub-plot in a story. Other solutions are ‘squashed’ commits and amending commits. 2.5.5 Viewing commits and diffs using git This is covered in an introductory git course, but on your local computer, you can view the history of commits in many ways Using git reflog in the terminal in your project’s directory Rstudio has a ‘history’ button in the ‘git’ control panel Visual Studio Code has an extensive git viewing system, and many extensions Other editors like Eclipse include git viewers There are dozens of desktop git graphical programs (that change frequently so we are not recommending any) 2.5.6 Viewing commits and diffs using GitHub The GitHub user interface makes it very easy to explore commits and code changes. For the workshop that this text supports, we walk through with an example. Bookdown project, code fix Commit: https://github.com/rstudio/bookdown/commit/65aed2a4421fa97215cc0074e8d1ceba63e1339c message: “error on generating description from a long sentence” NMML CRAWL project commit https://github.com/NMML/crawl/commit/e4f3b3e48b8d4fe738eca37c16c55247411d698e “ADD CHECKS FOR longlat/geographic data” GitHub allows you to add comments to commits. For example, to ask a question of your collaborator who made the commit (@kellykapsar do you think this will break the analysis later?). You can even add comments to a specific line in the code in commit (please help me untangle this insane dplyr command). Effective commits are an important communication tool for your collaborators, your future external collaborators, external users of your code, and maybe most importantly, your future self. 2.6 GitHub issue tracking We’ve mentioned GitHub issue tracking several times. While isse tracking is not a git feature or necessary to use git, this feature has been a cornerstone of open source collaboration within and outside of software development teams. The basic concept of an issue and its’ use is very simple. The second example of a commit above from the CRAWL project has an associated GitHub issue, and we know this because the dev who made the commit added a summary message “longlat or geographic coordinate reference systems are not supported. this adds explicit checks and throws an error if geographic coordinates are provided. Fixes #39” GitHub automatically links the issue ID number to the web page for the issue, which is “add error catch when sf object is in 4326”. Because the commit states it fixes this issue, we can assume that all the code necessary is in the commit, which you can confirm in the diff. The issue has the description “if an sf object is passed to crwMLE but with EPSG 4326, the fit will fail. However, no error message indicates this is a problem.” This describes the situation that causes the problem (related to the GIS coordinate reference system) and that when the problem occurs, the program doesn’t tell you. This program and problem are very specific to spatial ecology. Issues add another effective communication tool to commits besides just the commit message and optional summary. They merge project management and version control for more effective collaboration among diverse teams. 2.6.1 Alternatives GitHub is not the only service to use issue tracking, and there are other, industrial-strength project management tools that can create this link from issue to commit. Many other large open source projects use non-GitHub issue tracking tools (e.g., the Mozilla project), especially those that pre-date GitHub, or don’t want to depend on a commercial entity like GitHub.com. Can you find examples of clearly defined issues and how someone solved the problem in a code base or package that you use? We should note that when you view the commits on the program on your computer as described above, the issue number has no link since this is only a GitHub thing. There may be an extension or add-on for your programming editor that creates this link to GitHub for you. 2.6.2 Effective issues are focused Like commits, issues are most effective when they are focused, which is intuitively not unlike a to-do list. Writing “get organized” as an item on your to-do list is not very helpful. A typical workflow for combining GitHub issue tracking and commits is: Determine a problem to fix, or a feature to add Create an issue describing that in GitHub and note the issue number Edit your code to address the issue As you add and commit files, include the issue number in the commit message or summary. Test Push commits to the remote Repeat steps above until the issue is fixed Optionally add comments to the issue if you want to help your collaborators understand your approach, or more things to do Close the issue Note: This workflow is very appropriate for a project with a single developer. In addition, we mentioned earlier that there are methods for helping you organize or collect multiple commits for better communication. Git branches help both collaboration and communication (see below). 2.6.3 Example Issues Example: How ask package maintainers to accommodate the global dateline and very high latitudes https://github.com/rstudio/leaflet/issues/495 This is a great example of an obtuse issue. There is an R package “MapView” this is a 1-stop-mapping thing, super easy. Someone there raised an issue. MapView depends on RLeaflet (I just know this, it doesn’t say that anywhere in the issue). The leader of the MapView project realized that it was an RLeaflet problem, so copy/pasted the issue into the RLeaflet project. I say RLeaflet because that project actually heavily depends on the original leaflet.js for javascript, which most people just called “leaflet”. Another interesting thing is that the first commenter (Darcy somebody) says that polygons are fine, which does not need to be said because the OP already said it was ok, but no one piled on and said “he already said that.” Note the issue was raised in 2015 and no one was assigned and it was not fixed. The issue was reference in 2018 for new issue (created by Rstudio) to fix it, and I only know that because in the new issue they referenced the issue number. but even that one was not fixed. Also, in the original issue is an extensive post to show a work-around. That info now just sits here in a GitHub issue. A question for the group: What should have been done by the project to deal with this issue (Hints: Create an issue to add the work-around in the documentation, when creating a new issue, close the original and reference the new one. Possibly tag it as “wontfix” or better tag it in a project roadmap to make it clear they care about it and will deal with at some future time. See also https://github.com/rstudio/leaflet/issues/225 Example: ggmap package https://github.com/dkahle/ggmap/issues/326 Issue with Pacific mapping with ggmap. The solution is to change the projection – the software is not the problem, but is it in the docs? Another person had a question/problem but it was totally ignored: https://github.com/dkahle/ggmap/issues/295 Why is that? Is there a document for this package describing how to participate in the community? Are the volunteers following the lead of the owner? Who is fine ignoring these? 2.7 Practical git collab using branches You can think of branches as a kind of internal copy within your repository. When working on a branch, the files in the main repository are untouched. You can stage changes, make commits, and push/pull to remote within a branch and it won’t affect the main repository. This makes branches very useful when you want to make substantial changes to your repository that you’re not quite sure will work. Branches are also helpful when collaborating with others. If one person needs to run the main model, but you want to test out tweaking a few things, you can work on a branch while they stay on the main branch. Then, once your confident the changes in your branch are working correctly you can merge them from your branch back into the main repo. Branches also serve as method for organizing multiple commits together, especially if you are using a branch to address an issue. A typical workflow with branches is: Create or identify an issue that needs work on. Create a branch with a short name for that issue, and ideally include the issue number (e.g. 39-catch-4326-error if we use the example above). There are several methods and workflows for creating branches locally and on the remote, but that’s covered in a later workshop. Checkout the branch. Edit your code to address the issue and test. As you add and commit files, include the issue number in the commit message or summary. Push commits to the remote branch. Repeat steps above until the issue is fixed. Checkout the main branch. Merge your “featue branch” into main. Handle merge conflicts if necessary (see below). Some development teams include an issue number in the name of the branches. You shouldn’t using the # in the branch name, and GitHub does not automatically link a branch with an issue but this really helps identify what the branch was made for. 2.7.1 Merging and conflicts A really magical aspect of git is how it can merge two different sets of code without issue so often. However, “merge conflicts” do arise.They are a normal part of the development process when two things are changed near the same place, and it has a special way to deal with them. If a merge conflict happens, git places “conflict marks” inside your code, and the solution is simply to examine the two changes (incoming = stuff you are merging in) and “current” or “head” (which is the place you started from) and decide which to keep and what to change, and then removing the conflict marks. There is no magic other than your brain and your code editor. After solving the conflicts in the file, you add the file to the stage (see above) and commit. Then the merge can be completed. GitHub has a Resources: See section on “Basic Merge Conflicts in the git book Solving conflicts in git blog post by Jessica Temporal 2.8 Collaborative coding: Forking and pull requests Figure 2.3: Source When working on large open source project, it’s a good idea to not let anybody and everybody have immediate edit access to the repository where that project is kept. However, you still want to allow the broader user community to participate and contribute to the project. Forking is one way to address this problem. Forking a repository allows you to create a copy of a given repository (including all of its branches and history!) on your personal GitHub account. When you make changes to a forked repository, the original repository is not affected. However, if you have some changes that you think would help to improve the original project, you can submit a pull request to the owners of the original repository. If they like your change, then they can accept and incorporate (“pull”) it into the original project’s repository. Still confused? This webpage has a really nice explanation of forking vs. cloning, along with helpful diagrams. 2.8.1 Pull-request examples Fixing typos in the ‘bookdown’ package Example of “bookdown” markdown site with someone going through and fixing all the typos but not adding any content, which makes for a focused commit: https://github.com/rstudio/bookdown/commit/50a1c1edac61bab191a8808a252ba0bb21538f0e message: Fix typos (#1458) There is a GitHub pull request to merge this in, even for something this minor, to communicate with collaborators: https://github.com/rstudio/bookdown/pull/1458 2.9 Example of real-world detective work using GitHub Here is a detective story of how I found why my Python code was not working… and I blame the Pandas project. My commit where I describe the problem Found someone else that had the same problem Found this in the source-code for the documentation This is mentioned in the release notes for verion 1.5.0 The release notes have a link to the issue(s) for every change, including this one GH9568 , which spells out why the change was made. Since I didn’t even need to specify this parameter (it was using the default value!) I just removed it from my code, and learned my lesson to keep my code as simple as possible so that I don’t get burned by changes into the packages I depend upon. "],["repo-organization.html", "Chapter 3 Anatomy of a GitHub repository 3.1 Why read the source code? 3.2 Understanding different types of code bases 3.3 Finding and Using Documentation 3.4 Github Workflows", " Chapter 3 Anatomy of a GitHub repository We’ve learned about git and GitHub, which taught us how to communicate changes in code to ourselves and a broad audience, but what about the code itself? This section will help you decipher the files and folders in a code base to make use of it, regardless of where it may be. However, GitHub makes it very easy to navigate code, and is integral to communicate what the code is for. 3.1 Why read the source code? First, why would one want to be a GitHub tourist in the first place? Let set out a few reasons you may examine or use another project’s code (either via GitHub or from some other site): Track down a problem you are having by understanding how the code is working or has changed; Use the code to perform a function you need, either in whole or in part; To learn by seeing how others have written and organized code, programming structures, or files in a project. To change it, adding a feature or improve in some otherw ay An old phrase in open source programming to describe how to track down a problems or understand how a program works is “use the source, Luke!” Figure 3.1: Source Resources: “Reading Code Is an Important Skill. Here’s Why.” by Tammy Xu, builtin.com 3.2 Understanding different types of code bases There are many ways to categorize software, but (from the perspective of open science) let’s consider the axis of how we use the software. We find that there are (at least) three identifiable categories of code bases in terms of how you would use the code and maybe interact with the code base: package, project, and reference. There are many other ways to categorize software (language, function, outputs, domain, style, etc etc), seeing code bases in these categories may help you understand what kind of code base you are developing and thus organize your files and code. Note that the organizational principles and conventions we describe here are independent of whether a code base is a ‘repository’ (managed by git), or pushed to GitHub. We use GitHub to discover, explore, and use code but it could be anywhere – even emailed to you as a zip full of files and folders. 3.2.1 Package code base (installable) These are the free and open packages we install for R, Python, Julia, Java, Rust, etc etc. These could also be stand-alone programs written in any language. For example, we often use the GDAL system in spatial ecology. These may be called packages, libraries, binaries,extensions, etc. The goal of these packages is to be used by others for a general purpose. Most of the work we do is not to create packages, but if we find that our code is applicable to a larger class of problems than the one we are solving, it may be worth creating a package. As a user of such a package, you don’t need to access the code via GitHub - you can most likely install from a package system (like Pypi, R package mirror, or CRAN). 3.2.2 Project code base (useable) These code bases may not be installable projects, but are intended to be re-used by someone else, and that is often your future self! Many of these include instructions for cloning the code, getting all the pieces you need installed, and using the program. The main difference between how you might use a “project” type repository and a “package” type repo is that, because it’s not a package, you can’t typically use package installers like pip or install.packages(). Instead, you will need to clone the repository to your computer and follow the install/usage instructions. Example An example of a project code base is the MegaDetector on the MSU HPCC. This code was created for a handful of researchers at MSU to run a specific chunk of Python code to identify wildlife in millions of photos. There are already existing deep-learning model code bases, and an install GUI program, but nothing specific to running on MSU’s super computer. To accomplish this we forked just the pieces of code we needed from an existing system, modified it to do the work we needed, created ‘wrapper scripts’ that could run them on HPCC, and added documentation. (Note: It hasn’t been used in two years not and it would require updating to be used again.) 3.2.3 Reference code base (readable) There are many reasons why code is published for transparent reference rather than to be re-useable. For one, the programming effort to create code that’s usable by others is significant, which can delay or even hinder getting a computational analysis completed. Second, many of our research or academic code is useless without the input data, and those data sets are frequently not able to be published if they are acquired from a private source. Many projects use code to clean data sets in a reproducible way for use in analyses, but the configuration and setup required to keep these generic takes more time than available. However, there are many good practices one can follow to start with code that can be re-useable by others that we will cover in a later workshop. You may clone this type of repository as well, but don’t expect to be able to run much of it as they typically require specific input data or careful configuration of folders/files. Examples https://github.com/bioXgeo/neotropical_geodiv: R code to support the publication “Assessing the impact of scale-dependent geodiversity on species distribution models in a biodiversity hotspot”. This code, based on the Wallace R package, is organized to run specifically on MSU’s HPC with a large input data from a previous project. The code is published to demonstrate how the models were to run to generate the results in the publication. Source Code for the Apollo 11 Mission code base in ‘assembly language’ that controlled vehicles for space travels. This is clearly for reference! There are no computers on which this could run (Unless someone creates a virtual simulator of the Apollo command module that can run, which would be awesome…) https://github.com/krishnanlab/PyGenePlexus The Geneplexus project (Arjun Krishnan lab) creates and applies machine-learning models from gene networks to predict which novel genes may be related to a geneset one is interested in. It started as a reference code to support a paper. This lab then honed the code to be more organized and logical, and while the project was not ‘installable’ but had instructions downloading the code, organizing the data and running the functions in Python. We found creating an installable package made the system much easier to use for most people. At that point they not only organized the code into a PIP-installed package, they improved and organized the code even further. In addition, it made it easier to incorporate their code base into a website that created a graphical interface to selecting inputs and to visualizing the outputs. The web application could be a separate project that ‘imported’ the geneplexus package, rather than copy/pasted code that had to be constantly updated. The two projects(geneplexus package and geneplexus cloud-based web application) could be worked on concurrently. Which of these categories does the code for this book (and other books like it) fall into? If the book is to have several authors, then it may be a reuseable project. 3.3 Finding and Using Documentation Equally as important as code is the documentation. Without it we don’t know how to use the code, making it worthless! Here are some typical sources of documentation in the anatomy of a code base: The README file: Every code base should have a README file. While having a file named README is a longstanding tradition in source code, GitHub’s innovation was to show the README file below the code files, and to use markdown formatting to render a nice looking README Now this is a core feature of GitHub for many to have a great intro to their code. The README file does not have to be markdown and historically had no extension and was plain text (e.g. named README). Text Files: Historical open source linux code bases had several documentation files, usually all upper-case and with an extension, and plain text (For example: README, INSTALL, LICENSE). Windows does not like to open these files but they can be opened in a programming editor, or by right clicking and selecting “open with…” and picking TextEdit (Mac), Notepad (Windows). doc folder: This is the obvious place to look but may be buried in the repository. Binary formats :A colleague would always write his documentation using MS Word because he could easily format it and include screen shots as needed. The issue is that those files are not readable on GitHub, and they are not source code, so any changes can’t be tracked, and not everyone has MS Word, or a recent version.Even PDF, while universally readable in many browsers, can’t be tracked. Hence most packages use some form of text to write documentation, and Markdown makes this easy. generated: Packages use the technique of creating documentation by adding it directly into the code using special format, then running a documentation generator on it. Typically the documentation is not directly readable from the GitHub repository, but the software maintainer runs a utility to generate the documentation that may or may not be kept and readable in sub-folder. A common strategy is to put specially formatted comments (e.g. lines preceded by # in Python and R, or using /* .. */ block in C) before or inside the packages functions and files. The documentation generator reads these comments and converts them to human-readable documentation. R packages use the Roxygen2 utility, started in 2011 (I don’t know what happened to roxygen version 1), which is based on the Doxygen utility used for C &amp; C++ software from 1997. Roxygen2 can generate R help files, which are not in HTML or Markdown format so are not readable on GitHub. However, there is yet another R package (YARP) called PackageDown can generate a whole website from a properly formatted package. Python packages often use the Sphinx system for documentation. External websites: given the documentation generation systems often don’t output markdown, many developers opt to create documentation externally, and sometimes keep this documentation in a different GitHub project. For python a common place to keep documentation is the ‘readthedocs’ service 3.3.1 Code as documentation We hope we’ve already convinced you that reading source code is a good idea. Documentation is often an after thought of scientific programmers and so your best bet is to go directly to the code to determine what it does, and hopefully that code is written clearly with informative file, function, and variable names.Even if there is good documentation, the source code is the definitive way to learn what a program is actually doing. Like reading human language for understanding and interpretation, reading source code is a learned skill. In both cases you get better as you see more examples and understand the contexts and cultures embedded in the symbols. This article from ‘coderscat.com’ has some great pointers for that. Common advice given to help understand a code base is to run it yourself. This largely depends on the type of code (see the section on project types). 3.3.2 Tests: a great source of insight We don’t cover writing test code in this workshop, but you may have heard about it. It’s dependent on the language you are using. In short, in a successful code project someone will have written a set of short functions that check if the result from running the code matches what you’d expect. They are often run before you merge or push to a repository to ensure everything is working as expected. You don’t have to know how to write these tests to be able to read and learn from them. Most tests are in a “tests” or “test” folder. If you look to see the commands leading up to a test you can learn how the author of the code base expects the code to be used. 3.3.3 Other items documentation how to work with the code You may see the other following files in a repository. Often the files are names with all caps and no extension, especially if the project has some Unix/Linux provenance (as do many open source and research software projects). On some systems (including GitHub), upper case sorts before lower case, and so these files show at the top of a file listing since they are meant to be read before using the software. LICENSE: This documents under what conditions you may use thse software and pull from or change the code CONTRIBUTING: Good open source projects have instructions and guidelines for contributing to a project. This is very valuable for your own projects as they are instructions for your colleagues who may contribute code, or to your future self when you forget how you get everything setup! man directory: This is short for ‘manual’ and comes from Unix/Linux system called ‘man pages’ which I guess is for the manual as a collection of help files. 3.4 Github Workflows You may see frequent mention of GitHub workflows and how it can improve your coding live 200%! GitHub provides excellent features for automating processes you may repeat every time you push a commit or merge request. These time-savers come at the cost of a learning curve, and adapting your own work process to a git workflow. The important things about GitHub workflows are: If there is a .github folder, then the repository may be using workflows. If you fork this repo, the workflows may not run properly for you as they take some setup. That is OK. If you want to collaborate with a project, they may have automated workflows when you make a Pull Request (PR) that run tests or otherwise check your code. This may reject the PR but don’t fret – usually helpful developers will explain what you need to do to make the tests pass. Just ask! "],["engaging-with-the-community.html", "Chapter 4 Engaging with the community 4.1 Complain or Fix? 4.2 Requesting help/features or reporting bugs (using reprexes). 4.3 Engaging with the community", " Chapter 4 Engaging with the community Engaging with owners/maintainers and the broader coding community to identify and participate in discussion of issues. 4.1 Complain or Fix? Many simply write issues about what they want to see fixed or improved, but often the response is “put in a PR.” Instead, why not write the issue and present your proposed fix at the same time? That changes the tone from “here is problem”, and even better is asking “is this a problem?” Including the fix instead changes the conversation positively “is this a solution?” which is more efficient. If you can’t solve the problem, then of course you are not expected to proposed a fix it, but an offer to fix or help goes a long way. 4.2 Requesting help/features or reporting bugs (using reprexes). 4.2.1 Example: How ask package maintainers to accommodate the global dateline and very high latitudes https://github.com/rstudio/leaflet/issues/495 This is a great example of an obtuse issue. There is an R package “MapView” this is a 1-stop-mapping thing, super easy. Someone there raised an issue. MapView depends on RLeaflet (I just know this, it doesn’t say that anywhere in the issue). The leader of the MapView project realized that it was an RLeaflet problem, so copy/pasted the issue into the RLeaflet project. I say RLeaflet because that project actually heavily depends on the original leaflet.js for javascript, which most people just called “leaflet”. Another interesting thing is that the first commenter (Darcy somebody) says that polygons are fine, which does not need to be said because the OP already said it was ok, but no one piled on and said “he already said that.” Note the issue was raised in 2015 and no one was assigned and it was not fixed. The issue was reference in 2018 for new issue (created by Rstudio) to fix it, and I only know that because in the new issue they referenced the issue number. but even that one was not fixed. also in the original issue is an extensive post to show a work-around. That info now just =sits here in a github issue. A question for the group: what should have been done by the project to deal with this issue (hints, create an issue to add the work-around in the documentation, when creating a new issue, close the original and reference the new one.. possibly tag it as “wontfix” or better tag it in a project roadmap to make it clear they care about it and will deal with at some future time. https://github.com/rstudio/leaflet/issues/225 4.2.2 Example: ggmap package Issue with Pacific mapping with ggmap: https://github.com/dkahle/ggmap/issues/326 * (solution is to change the projection, the software is not the problem, but is it in the docs?) * Another person had a question/problem but it was totally ignored: https://github.com/dkahle/ggmap/issues/295 + Why is that? + Is there a document for this package describing how to participate in the community? + Are the volunteers following the lead of the owner? + Who is fine ignoring these? 4.3 Engaging with the community Engaging with owners/maintainers and the broader coding community to identify and participate in discussion of issues. "],["exercise.html", "Chapter 5 Exercise: Working with someone else’s repo 5.1 About Markdown 5.2 Instructions", " Chapter 5 Exercise: Working with someone else’s repo For this exercise, you are going to use forking, commits, and pull requests to edit somebody else’s repo. That somebody else is us - You will be editing this repo. Follow the instructions below to walk through this process. 5.1 About Markdown The ‘code’ in this repository is actually “markdown”, which is code that is translated to formatted prose. Markdown is a very easy format to learn, very widely used, and we used it for this book. Github has it’s own ‘flavor’ of markdown (GFM). This cheatsheet gives a brief introduction to Markdown. For this exercise, please review how to create links using [] and (). 5.2 Instructions Note: Feel free to work on your own or in small groups for this exercise. Choose from the following options: Identify a public repository on GitHub that falls into one of the three categories we discussed (package, project, reference). Note: We’re especially looking for some more Python-based examples/repositories! Identify a resource (website, tutorial, youtube video, etc.) that you find useful that relates to the content of this class. Create a fork of the repository used to create the “book” for this class (IBEEM-MSU/ibeem-collaborative-coding) Bonus: If you’re feeling adventurous and want to work like a true programmer, create a branch off of your forked repository and commit the changes below to that branch before submitting the pull request from your branch to the “main” branch of our repo. If this makes no sense, just pretend you didn’t read this bullet for now. Edit the text of the 10-resources.rmd file to add in your repository/resource. Note: You can edit the text directly in GitHub (Click the pencil-shaped “Edit this File” button in the upper right hand corner after you click on the file name.) or you can clone a copy down to your computer to edit in your preferred integrated development environment (VS Code, RStudio, etc.). Create a descriptive commit message describing your change (and push to remote if working from a cloned repository). Navigate back to the main page for the original repo and create a pull request. Click the link to compare across forks at the top of the pull request. Write a pull request that references your commit (use your commit hash to do so) and submit. Pat yourself on the back for doing our job for us by generating resources/examples for future workshops! Figure 5.1: Artwork by @allison_horst "],["conclusions.html", "Chapter 6 Conclusions", " Chapter 6 Conclusions Thank you so much for attending our Collaborative Coding workshop! We hope that you learned something new that you will take with you into your research practice or share with others. Given that this is the first (but not the last!) time we plan to run this workshop, we are eagerly hoping for a lot of constructive criticism to help us improve for next time. In this vein, we would really appreciate it if you would fill out this short (5 question), anonymous survey before you leave today. Thank you! "],["glossary.html", "Chapter 7 Glossary 7.1 Branch: 7.2 Commit: 7.3 Commit hash: 7.4 Changeset: 7.5 Git flow: 7.6 Git log graph: 7.7 GitHub flavored-markdown (GFM): 7.8 Issue: 7.9 Markdown: 7.10 Pull request (PR): 7.11 Repository (Repo): 7.12 Remote: 7.13 Squashed commits:", " Chapter 7 Glossary 7.1 Branch: An independent development stream within a repository where you can develop new features independently without the fear of interrupting others’ workflows. See this book chapter for more info. 7.2 Commit: A labelled set of changes to the code. A single commit an include changes to one or multiple files. 7.3 Commit hash: A nickname for the 40 character git commit SHA-1 checksum value which represents a unique ID given to each commit in a git repo. Commit hashes are also often presented in their shortened 8-character form. 7.4 Changeset: Another name for the set of changes in a particular commit. 7.5 Git flow: A strategy for organizing branches within a repository. Typically includes 5 branch types: Main, Develop, Feature, Release, and Hotfix. See this nice cheatsheet or this explanation for more info. 7.6 Git log graph: Also called a source tree or “graph”, git log graphs are a visual representation of the structure of a repository (e.g., branches and commits) generated using the commits git log --graph. A lot of software also has built-in git log graphs. 7.7 GitHub flavored-markdown (GFM): GitHub’s version of the markdown syntax, which contains some additional functionality. See this great overview in GitHub’s Documentation for more info. 7.8 Issue: A feature of GitHub that allows users to identify problems/bugs, keep track of tasks, receive feedback on changes, etc. See GitHub’s documentation section on Issues for more details. 7.9 Markdown: A text-encoding system that allows you to format plain text and make it fancy (e.g., bold, italics). Markdown file extensions are “.md”. The text of this book is written in markdown - if you want to check out some of the .rmd files (short for R Markdown), follow this link. 7.10 Pull request (PR): A way to “request” that the maintainers of a repository (sometimes you or sometimes somebody else) “pull” a set of changes that you’ve proposed into another branch. Pull requests can be used to merge changes from one branch to another within a single repository (see here for more details) or between a forked version of a repository (e.g., one that you don’t have write access to) and a branch in the original repository (see here for more info). 7.11 Repository (Repo): A collection of files that Git keeps track of. 7.12 Remote: The copy of the repository that is hosted on the internet or another serve (i.e., not the “local” version on your computer). 7.13 Squashed commits: A way to effectively combine multiple previous commits into one new commit. (Note: technically the previous commits are not deleted, but for all intents and purposes you’ve now “squashed” them into one new commit.) Squashed commits can be very helpful when working on a branch that you want to then pull request to merge back into another branch. "],["resources.html", "Chapter 8 Resources 8.1 Data Wrangling 8.2 Data Processing 8.3 Git/GitHub and Version Control 8.4 Example repositories", " Chapter 8 Resources Eager to dive deeper into collaborative coding? Here are some more great resources that delve into specific areas we’ve overviewed during this workshop. 8.1 Data Wrangling Data Cleaning and Quality Control (Environmental Data Initiative): A great overview of best practices in organizing data sets, arranging data tables, and defining levels of data processing (Note: Focus on environmental data, but principles apply to any discipline). Metadata and the Ecological Metadata Language (Environmental Data Initiative): Introduction to Ecological Metadata Language with tools for creating EML-formatted metadata (Note: Focus on environmental data). 8.2 Data Processing Data pipelining in R using the Targets package (Targets for Ecologists): A step-by-step walkthrough guide for using the data pipelining tool “Targets” in the R programming language. Data pipelining is a great way to ensure reproducibility and speed up the generation of results by setting up the computer to keep track of all the steps in your analysis and re-running only those that are alterred when you make a change to the code. R doParallel: How to Parallelize R DataFrame Computations (Radečić 2024): Overview of the doParallel package in R and its ability to speed up data analyses by running in chunks of data in parallel. Implementing GitHub Actions continuous integration to reduce error rates in ecological data collection (Kim et al. 2022) 8.3 Git/GitHub and Version Control Learn git branching interactively: A fun walk-through to learn basic git commands, including working on branches. Also includes some more advanced git techniques. Not just for programmers: How GitHub can accelerate collaborative and reproducible research in ecology and evolution (Braga et al. 2023) Excuse Me, Do You Have a Moment to Talk About Version Control? (Bryan 2018): (Note: Full text available with MSU login) 8.4 Example repositories 8.4.1 Package 8.4.2 Project 8.4.3 Reference "],["appendix-workshop-outline.html", "Chapter 9 Appendix: Workshop Outline 9.1 Intro (15 min) 9.2 Seminar/Demo (65 min) 9.3 Hands-on (20-25 min) 9.4 Conclusion (15 min) 9.5 Follow-up Survey", " Chapter 9 Appendix: Workshop Outline This is the outline and time for a 2-hour in-person workshop based on this book 9.1 Intro (15 min) Intro focus of this workshop participant introductions, optional discussion of previous experiences ensure everyone has a github account 9.2 Seminar/Demo (65 min) git/github in practice (25 mi) framework code -&gt; git -&gt; github why use git and github? list of git features/ commands we are assuming familiarity with in a git vs. github comparison foreach {commits, issues, branches, forks &amp; pull requests, rebase}: (Kelly) define the term/feature: review of the feature, rely on previous workshops/existing doc (as written for ch2) (Kellly) point to how github works with this, link to github images and docs (Pat) describe important elements of this feature in practice: principles of using commits, how much code to put into a commit and why ( this helps to understand the language of OSS collaboration ) (Pat) outline a typical workflow for using the feature this helps to understand the context of the culture of OSS collaboration real world example Anatomy of a codebase (15 min) common elements (cover licensing here in 1 sentence and a link) our taxonomy example codebases Using other’s code in your work (10 minutes) Engaging with issues and PRs ( 15 mintues ) demo of that for a README file (Pat/Beth’s repo) demo of that with our own book 9.3 Hands-on (20-25 min) Exercise: work through a real PR (20-25 mintues) introducing bookdown and Markdown ensure everyone has a github account exercise optional, bug bounty, find a typo or other bug and create issues in our repo optional: download RStudio and create book to test it! 9.4 Conclusion (15 min) 9.5 Follow-up Survey "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
