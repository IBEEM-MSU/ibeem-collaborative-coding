# Github Orientation
This chapter will provide orientation to open science code repositories, via github, so you can find and use code that may be useful to you. 

We learned to organize and work through our own projects by observing how others organize theirs. The amazing thing is that you can find hundreds of excellent examples to learn from as even major companies put their code on github.  


## What is a code-base? 

In this book we may use the terms "repository", "project", or "code-base" interchangeably but they have slightly different meanings: 

- "Code base" is a colloquial term for any collection of related to code in one or more files that works together to perform a function, or provide an application. 

- A "repository" is an collection of code managed by git, not necessarily on an external server (either on GitHub or elsewhere). This could be on your laptop. The database of version history is inside the .git folder, and so that .git folder is the repository. We say this is a "Git repo"

- GitHub also calls their units  a "repository", so in GitHub the URL pattern `github.com/<user_name>/<repository_name>` contains a Git repository (and possibly more than one )  

- We may think of projects as code base plus associated data files, and all of the work needed to complete the research. However, Git hub uses "project" to mean "project management features" (task tracking, due dates, work progress monitoring) which can be used for one or more repos.  A research project may require multiple repos (one for data entry & cleaning, one for analysis, and one for a website to show it all off) and a Git hub project can tie those together. This is a new feature that we won't go into much but we will go into the existing project management features that GitHub has for repos (issue tracking)


## Git vs. GitHub

There is frequent confusion between which aspect of using Git  GitHub for code mamagement is from Git vs. GitHub. The following table attempts to clarify which concept and feature are part of the Git system and can be used independently from GitHub.   GitHub is the most widely used 'remote' Git server as it offers great collaboration features. 

| Feature originally of Git | Feature of GitHub Service |
| --- | ---|
|  Git does not have way to track problems and to-do items.| **Issue tracking** and other project management features are not connected to Git, but GitHub helps to integrate project management with Git. |
| **commit**: Track code changes and add a message describing this change (see [reading commits](#reading_commits)).                        | Collaborators can add comments on commits beyond the commit.<br />GitHub issues can be cross-referenced in commit messages. |
| **diff**: Show the difference in two change sets. <br />Can use command line, programming editor (Rstudio, VSCode, Eclipse, etc), or a specialized desktop application (MergeTool from Apple). | Comments directly in code changes per line and create/share perma-links per line for feedback from collaborators. |
| **branch**: Git tracks these code versions for you and can provide lists using `git status`, `git branch -a`, etc.<br />Many programming editors have a feature to visualize the tree/graph of branches. | GitHub allows you to easily show and switch between branches to compare without having to 'checkout' in your current directory and initiate a merge from there. |
| **merge**: Combine changes from one branch to another using several different methods, alert when there are conflicts and resolve conflicts.   Can add a merge commit message to communicate. | GitHub has an interface for merging directly on the website to help you preview what will happen without affecting your local repository or the main branch. |
| **Fork**: A copy of a repository that someone has decided to work on independently. In Git, the repo that you forked from is called the 'upstream' repository. | GitHub has a button to fork a repository into your own account and keeps track of where that fork comes from (which GitHub also called the 'upstream' repository). |
| **remote/clone/push/pull**: Git has the concept of a remote repository running on a server that you can clone (download), push up changes, pull down others' changes into your code. The word 'origin' is a Git convention. | GitHub is a remote server that hosts remote repositories and provides the URL to you to be able to clone, push, or pull. |
|  | "**pull request**" A system invented by GitHub to facilitate external collaboration. Enables commenting, review, and connections to the issue tracking system. This perhaps is the core feature of GitHub. Note that other Git servers use different terms, for example Git servers at gitlab.com calls them '*merge requests*'. |



## Git Features in GitHub

This workshop assumes you've been trained in git, but perhaps not GitHub.  GitHub makes most of the features of Git very easy to find, and here are links to GitHub's help for each of them: 

<!-- code note: attempting to use bookdown image sizing features here https://bookdown.org/yihui/rmarkdown-cookbook/figure-size.html --> 

- [Remote URL, Cloning](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository)<br>
![GitHub ui for cloning](https://docs.github.com/assets/cb-69468/mw-1440/images/help/repository/https-url-clone-cli.webp){width=50%}

- [Branching](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-and-deleting-branches-within-your-repository)<br>
  ![image of branch UI in GitHub](https://docs.github.com/assets/cb-36155/mw-1440/images/help/repository/file-tree-view-branch-dropdown-expanded.webp){width=50%}

- [Commits](https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/about-commits) <br/>
  ![GitHub ui for viewing commits](https://docs.github.com/assets/cb-48474/mw-1440/images/help/commits/commits-page.webp){width=50%}
  

## Reading and Interpreting Git Commits like an Historian {#reading_commits}

Resources
* [GitHub's Git guide to commits](https://github.com/git-guides/git-commit)

Reading through Git commits can help you to learn how a repository has grown, who has contributed, and why changes were made. 

Git and commits are a form of communication with your colleagues, the public, and yourself. 

### How people communicate using commit messages
Perspective of commit messages as communication can change what you include in a commit (independent of GitHub). 


### Review commits

Git is much more than just a backup system, or a way to keep track of things. it's a means to communicate about code, and the heart of this is the commit. 

#### Viewing commits and diffs using GitHub

 - The user interface (walk through with an example)
 - A good message succinctly says what was changed and why 
 - Linking with issues

A good commit is focused on solving a single problem or making a change that helps implement a small feature. This way it's very clear what code was changed or added and why. A commit is not a way to 'backup' your code.  There are other ways to do that.  A commit that says "nightly commit" tells me nothing about why the code was changed.  A commit should include all the changes necessary to solve a small issue, and the code should run after a commit is done. Viewing other devs commit log help you to understand how to use Git more effectively.

Since I often make mistakes, I often think a change is complete and commit my code, only to find a typo or other problem I missed. It's possible to 'squash' commits into a single commit (the details will be discussed in a later workshop). You may see commits that encompass many changes and seem perfect - they may actually be several commits that were 'squashed.`   

​	

#  Anatomy of a code repository {#repo-organization}
<!-- move to a new chapter? -->

We've learn about Git and GitHub, including how to track and communicate changes in code, but what about the code itself? This section is designed to help you decipher the files and folders in a code base in order to make use of it, regardless of its structure. Thankfully, GitHub makes it very easy to navigate code, and is integral to communicate what the code is for. 

## Why read the source code?

Why would one want to be a GitHub tourist in the first place? Let set out a few reasons you may examine or use another project's code (either via GitHub or from some other site):

- Track down a problem you are having by understanding how the code is working or has changed;
- Use the code to perform a function you need, either in whole or in part;
- Learn by seeing how others have written and organized code, programming structures, or files in a project. 
- Change the code, e.g., by adding a feature or improving it in some other way 

An old phrase in open source programming to describe how to track down problems or understand how a program works is "use the source, Luke!" 

```{r source, echo=FALSE, out.width= "50%", fig.align="center", fig.cap="[Source](https://blog.codinghorror.com/learn-to-read-the-source-luke/)"} 

knitr::include_graphics("./figures/UseTheSourceLuke.jpg")
```


There are dozens of blog posts explaining why reading source code is valuable. But you may be here to 
Are there other reasons? 

Resources:

-  ["Reading Code Is an Important Skill. Here’s Why. "](https://builtin.com/software-engineering-perspectives/reading-code) by Tammy Xu, builtin.com


## Understanding different types of code bases

There are many ways to categorize software, but (from the perspective of open science) let's consider the axis of how we use the software. In terms of how you would use the code and interact with a code base, We find that there are (at least) three identifiable categories of code bases: packages, projects, and reference code bases. 

There are many other ways to categorize software (language, function, outputs, domain, style, etc etc). However, seeing code bases in these categories these may help you understand what kind of code base you are developing and thus organize your own files and code.  

Note that the organizational principles and conventions we described are independent of whether a code base is  a 'repository' (managed by Git), or pushed to GitHub. We use GitHub to discover, explore, and use code but it could be anywhere (even emailed to you as a zip full of files and folders).  

 
### Package code base (installable)

These are the free and open packages we install to more efficiently use R, Python, Julia, Java, Rust, etc etc. These could also be stand-alone programs written in any language. For example, we use the GDAL system frequently for spatial data analysis. 

These may be called packages, libraries, binaries,extensions, etc. 

The goal of these packages is to be used by others for a general purpose. Most of the work we do is not to create packages, but if we find that the code we are writing is applicable to a larger class of problems than the one we are solving, it may be worth creating a package. 

As a user of such a package, you don't need to access the code via GitHub - you can most likely install from a package system (like Pypi, R package mirror, CRAN).

### Project code base (useable) 

These code bases may not be installable projects, but are intended to be re-used by someone else...and that is often your future self! Many project code bases include instructions for cloning the code, getting all the pieces you need installed, and using the program. 

An example of this is the [MegaDetector on the MSU HPCC](https://github.com/billspat/hpcc_megadetector) which was created for a handful of researchers at MSU to run a specific chunk of Python code to identify wildlife in millions of photos. There are already existing deep-learning model code, and an install GUI program, but nothing specific to running on MSU's super computer. To accomplish this, we forked just the pieces of code we needed from this existing system, modified it to do the work we needed, created 'wrapper scripts' that could run them on HPC, and added documentation. (Note: It hasn't been used in two years not and it would require updating to be used again.) 

Another example of 'project' repositories are specific-purpose web applications.If your goal is to create a web application to help others use your software (rather than write a desktop application or leave it as command line only) then starting with an existing ***FINISH IDEA HERE***


### Reference code base (readable) 

There are many reason why code is published that may not require it to be fully reusable. For one, creating code that's usable by others requires significant programming effort, which can delay or even hinder simply getting a computational analysis completed. Second, many of our research or academic code is useless without the input data, and those data sets are frequently not able to be published if they are acquired from a private source.  

Many projects use code to clean data sets in a reproducible way for use in analyses, but the configuration and setup required to keep these generic takes more time than available.   

However there are many good practices one can follow to start with code that can be re-useable by others that we will cover in a later workshop. 


## Examples by Codebase Types

### Reference: 

Here is a codebase in 'assembly language' that controlled vehicles for space travel:  [Source Code for the Apollo 11 Mission](https://github.com/chrislgarry/Apollo-11)

This is clearly for reference!  There are no computers on which this could run (unless someone creates a virtual simulator of the Apollo command module, which would be awesome...) 


***Examples of some reference code that became a package**

The Geneplexux project is from MSU in the Arjun Krishnan Lab and is a system that creates and applies machine-learning models from gene networks to predict which novel genes may be related to a geneset one is interested in. It started as a project of code that demonstrated the basis of the system (e.g. reference code). This lab then honed the code to be more organized and logical. While the project was not 'installable', it had instructions for downloading the code, organizing the data and running the functions in Python. The creators then found that creating an installable package made the system much easier to use for most people. At that point they not only organized the code into a PIP-installed package, they also improved and organized the code even further. In addition, it made it easier to incorporate their code base into a website that created a graphical user interface (GUI) that allowed visitors to select inputs and to vizualize the outputs.  The web application could be a separate project that 'imported' the geneplexus package, rather than integrating the code. The two project (geneplexus package and geneplexus cloud-based web application) could proceed concurrently. 

Which of these categories does the code for this book (and other books like it) fall into If the book is to have several authors, then it may be a reusable project. The project will have enough instructions to allow for ***FINISH IDEA HERE***

## Implications of code base type for re-use

How you may still use code that can't be 'installed' as a package

# Finding and Using Documentation

<!-- note this replaces what is currently chapter 5 -->

## Important elements to look out for:

* **The README file**: While having a file named README is a longstanding tradition in source code, GitHub's innovation was to show the README file below the code files, and to use markdown formatting to render a nice looking README. Now this is a core feature of GitHub. However, the README file does not have to be markdown and historically had no extension and was plain text (e.g. named `README`)

* **Text Files**: Historical open source linux code bases had several documentation files, usually all upper-case and with an extension, and plain text. (For example: `README`, `INSTALL`, `LICENSE`). Windows does not like to open these fiels but they can be opened in a programming editor, or by right clicking and selecting "open with..." and picking TextEdit (Mac) or Notepad (Windows). 

* **doc folder**: This is the obvious place to look but may be buried in the repository.  

* **Binary formats**: A colleague would always write his documentation using MS Word because he could easily format it and include screen shots as needed. The problem with this approach is that those files are not readable on GitHub, and they are not source code, so any changes can't be tracked, and not everyone has MS Word, or a recent version. Even PDF, while universally readable, cannot be tracked in many browsers. Hence most packages use some form of text to write documentation, and Markdown makes this easy. 

* **generated**: Packages use the technique of creating documentation by adding it directly into the code using special formatting, then running a documentation generator on it. Typically the documentation is not directly readable from the GitHub repository, but the software maintainer runs a utility to generate the documentation that may or may not be kept and readable in sub-folder. A common strategy is to put specially formatted comments (e.g. lines preceeded by `#` in Python and R, or using `/* .. */` block in C) before or inside the packages functions and files. The documentation generator reads these comments and converts them to human-readable documentation. 

R packages use the [Roxygen2](https://roxygen2.r-lib.org) utility starting in 2011 (I don't know what happened to roxygen version 1), which is based on the [Doxygen](https://en.wikipedia.org/wiki/Doxygen) utility used for C & C++ software from 1997. Roxygen2 can generate R help files, which are not in HTML or Markdown format so are not readable on GitHub. However there is yet another R pacakge (YARP) called PackageDown which can generate a whole website from a properly formatted package.  

Python packages often use the [Sphinx](https://www.sphinx-doc.org/en/master/) system for documentation. 

* **External websites**:  Given that documentation generation systems often don't output markdown, many developers opt to create documentation externally, and sometimes keep this documentation in a different GitHub project. For Python, a common place to keep documentation is the ['readthedocs'](https://docs.readthedocs.io/) service.

## Code as documentation

We hope we've already convinced you that reading source code is a good idea. Documentation is often an after thought of scientific programmers and so your best bet is to go directly to the code to determine what it does, and hopefully that code is written clearly with informative file, function, and variable names.  Even if there is good documentation, the source code is the definitive way to learn what a program is actually doing.  

Like reading human language for understanding and interpretation, reading source code is a learned skill. In both cases you get better as you see more examples and understand the contexts and cultures embedded in the symbols. [This article](https://coderscat.com/learn-from-source-code/) from 'coderscat.com' has some great pointers for that. 

Common advice given to help understand a code base is to run it yourself. This largely depends on the type of code (see the section on project types). 

### Code tests are a great source of insight

We don't cover writing test code in this workshop, but you may have heard about it. In short, in a successful code project someone will have written a set of short functions that check if the result from running the code matches what you'd expect. They are often run before you merge or push to a repository to ensure everything is working as expected. 

You don't have to know how to write these tests to be able to read and learn from them.  Most tests are in a "tests" or "test" folder. If you look to see the commands leading up to a test you can learn how the author of the code base expects the code to be used. 

### Other items documentation how to work with the code

You may see other common file types/names in a repository.  Often the files are names with all caps and no extension, especially if the project has some  Unix/Linux provenance (as do many open source and research software projects). On some systems (including GitHub), upper case sorts before lower case, and so these files show at the top of a file listing since they are meant to be read before using the software. 

 - `LICENSE`: See the chapter on licensing [here]()***INSERT LINK TO LICENSING CHAPTER***. This file documents under what conditions you may use software and pull from or change the code.
 - `CONTRIBUTING`: Good open source projects have instructions and guidelines for contributing to a project. This is very valuable for your own projects as they are instructions for your colleagues who may contribute code, or to your future self when you forget how you get everything setup!  
 - `man`: This is short for 'manual' and comes from Unix/Linux system called 'man pages' which I guess is for the manual as a collection of help files. 


## Versioning and releases

### Forks

## Using someone elses code

### Dependencies/requirements

### Interaction of source scripts 

# Collaboration (ch 4)

# Collaborating with GitHub {#collaborating}



<!-- keep this in ch. 4 -->

## Project management with GitHub
Using GitHub's project management lite features

## Issue management
What is issue management? 
Following issues and their fixes can help you track down your bugs 

### Pandas Example: 
* [My commit](https://github.com/krishnanlab/geneplexus_app/commit/80256c10d65f22fdd63898225948e36d4d63d29b)  
* [Found someone else that had the same problem](https://github.com/pandas-dev/pandas/issues/8206) 
* [Found this in the source-code for the documentation](https://github.com/pandas-dev/pandas/blob/bdc79c146c2e32f2cab629be240f01658cfb6cc2/pandas/core/generic.py#L3888)
* [This is mentioned in the release notes for verion 1.5.0](https://pandas.pydata.org/pandas-docs/version/1.5/whatsnew/v1.5.0.html#other-deprecations)
  + The release notes have a link to the issue(s) for every change, including this one GH9568 , which spells out why the change was made.
* Since I didn't even need to specify this parameter (it was using the default value!) I just removed it from my code, and learned my lesson to keep my code as simple as possible so that I don't get burned by changes into the packages I depend upon.  


## Communication using issues 

### Requesting help/features or reporting bugs (using reprexes). 

### Example: How ask package maintainers to accommodate the global dateline and very high latitudes 
* https://github.com/rstudio/leaflet/issues/495
  + This is a great example of an obtuse issue. There is an R package "MapView" this is a 1-stop-mapping thing, super easy. Someone there raised an issue.  MapView depends on RLeaflet (I just know this, it doesn't say that anywhere in the issue). The leader of the MapView project realized that it was an RLeaflet problem, so copy/pasted the issue into the RLeaflet project. I say RLeaflet because that project actually heavily depends on the original leaflet.js for javascript, which most people just called "leaflet". Another interesting thing is that the first commenter (Darcy somebody) says that polygons are fine, which does not need to be said because the OP already said it was ok, but no one piled on and said "he already said that." Note the issue was raised in 2015 and no one was assigned and it was not fixed.  The issue was reference in 2018 for new issue (created by Rstudio) to fix it, and I only know that because in the new issue they referenced the issue number.   but even that one was not fixed.  also in the original issue is an extensive post to show a work-around. That info now just =sits here in a GitHub issue.   A question for the group: what should have been done by the project to deal with this issue (hints, create an issue to add the work-around in the documentation, when creating a new issue, close the original and reference the new one.. possibly tag it as "wontfix" or better tag it in a project roadmap to make it clear they care about it and will deal with at some future time.
* https://github.com/rstudio/leaflet/issues/225

### Example: ggmap package
Issue with Pacific mapping with ggmap: https://github.com/dkahle/ggmap/issues/326 
* (solution is to change the projection, the software is not the problem, but is it in the docs?)
* Another person had a question/problem but it was totally ignored: https://github.com/dkahle/ggmap/issues/295  
  + Why is that?  
  + Is there a document for this package describing how to participate in the community?  
  + Are the volunteers following the lead of the owner?
  + Who is fine ignoring these?

<!-- create a new chapter for this topic -->

# Engaging with the community 

Engaging with owners/maintainers and the broader coding community to identify and participate in discussion of issues. 


<!-- move this to to Ch. 3 Tour of GitHub -->

## What is a 'pull request?' (PR) (hint: it's a GitHub thing)
* A PR lifecycle: 
  + Issue
  + Fork/Branch
  + PR
  + Merge

## Github link awesomeness
* Permalinks in code and issues
* References to issues from commits and referencing to commits from comments




you can say "here is problem" or you can ask "is this a problem?"  but a PR instead changes  the conversatin to  "is this a solution?" which is more efficient



in excercise, give them several things to be 1) making branch and editing 2) creating PR 3) forking 4) adding a comment ot the code, issue or merge request









