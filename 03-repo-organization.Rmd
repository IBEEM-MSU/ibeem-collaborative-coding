# Github Orientation
This chapter will provide orientation to open science code repositories, via github, so you can find and use code that may be useful to you. 

We learned to organize and work through our own projects by observing how others organize theirs.  The amazing thing is that you can find hundreds of excellent examples to learn from as even major companies put their code on github.   


## What is a code-base? 

In this book we may use the terms "repository", "project", or "code-base" interchangeably but they have slightly different meanings: 

- "Code base" is a colloquial term for any collection of related to code in one or more files that works together to perform a function, or provide an application.  

- A "repository" is an collection of code managed by git, not necessarily on an external server (either on github or elsewhere).  This could be on your laptop.  The database of vesion history is inside the .git folder, and so that .git folder is the repository.  We say this is a "git repo"

- Github also calls their units  a "repository", so in Github the URL pattern `github.com/<user_name>/<repository_name>` contains a git repository (and possibly more than one )  

- We may think of projects as code base plus associated data files, and all of the work needed to complete the research.  However, git hub uses "project" to mean "project management features" (task tracking, due dates, work progress monitoring) which can be used for one or more repos.   A research project may require multiple repos (one for data entry & cleaning, one for analysis, and one for a website to show it all off) and a git hub project can tie those together.  This is a new feature that we won't go into much but we will go into the existing project management features that github has for repos (issue tracking)

## Github in context

Think of these systems as a path, building up each other: 

1. code : files
2. git : managed repository of files
3. github: service for enhanced collaboration, communication and project managment based on git

The heart of all of this is the code, and when one is trying to learn git and github as they presented it appears that github owns the code, but it's just a service.  Code is money and github is just the bank.  

## Git vs. Github

Even expereinced coders are unsure of the boundary between git and github.   The following table attempts to clarify which concept and feature are part of the git system and can be used independently from github.    Github is the most widely used 'remote' git server as it offers great collaboration features.  

| Feature originally of Git | Feature of Github Service |
| --- | ---|
|  git does not have way to track problems and to-do items| **issue tracking** and other project management features are not connected to git, but github helps to integration project management with git |
| **commit**: <br />track code changes and add a message describing this change (see [reading commits](#reading_commits) )                        | collaborators can add comments on commits beyond the commit<br />github issues can be cross-referenced in commit messages |
| **diff**: show the difference in two change sets, <br />can use command line, programming editor (Rstudio, VSCode, Eclipse, etc), or a specialized desktop application (MergeTool from Apple) | comments directly in code changes per line and create/share perma-links per line for feeback from collaborators |
| **branch**: git tracks these code versions for you and can provide lists using `git status`, `git branch -a` etc<br />many programing editors have a feature to visualize the tree/graph of branches | github allows you to easily show and switch between branches to compare without having to 'checkout' in your current directory.  and initiate a merge from there |
| **merge**: combine changes from one branch to another using several different methods, alert when there are conflicts and resolve conflicts.    Can add a merge commit message to communicate | github has an interface for merging directly on the website to help you preview what will happen without affecting your local repository, or the main branch |
| **Fork**: simply copy of a repository that someone has decided to work on independently.    In git, the repo that you forked from is called the 'upstream' repository. | Github has a button to fork a repository into your own account, and keeps track of where that fork comes from, and which github also called the 'upstream' repository. |
| **remote**: git was designed to share, and so the original 'git' program has a feature built in to act as server from which you can clone (download) a repo, push (up) changes, pull (down) others changes into your code.  An external git server is a 'remote.'  However the 'git server' requires the command line to run and has no web interface built in. | At it's core, Github is a git server and provides a URL for repos for clone, push or pull.  Unlike git, github can do this using WWW protocols and websites.  There are other systems that provide the same 'remote' service as github|
|  | "**pull request**" is a process invented by github (and others) to facilitate accepting code from external collaborators.  Additionally it fosters communication among collaborators, given them the ability to comment on code, contact reviewer, and connect to an issue tracking system.  This perhaps is the core feature of github.  Note that other git servers use different terms, for example git servers at gitlab.com calls them '*merge requests*' |
|    | "**issue**"  Issue tracking is not unique to git workflows, but general project management practice.  github has 'lite' project management features that integrate with git and code |


## git Features in Github

This workshop assumes you've been trained in git, but perhaps not github.   Github makes most of the features of git very easy to find, and here are links to github's help for each of them: 

<!-- code note: attempting to use bookdown image sizing features here https://bookdown.org/yihui/rmarkdown-cookbook/figure-size.html --> 

- [Remote URL, Cloning](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository)<br>
![github ui for cloning](https://docs.github.com/assets/cb-69468/mw-1440/images/help/repository/https-url-clone-cli.webp){width=50%}

- [Branching](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-and-deleting-branches-within-your-repository)<br>
  ![image of branch UI in github](https://docs.github.com/assets/cb-36155/mw-1440/images/help/repository/file-tree-view-branch-dropdown-expanded.webp){width=50%}

- [Commits](https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/about-commits) <br/>
  ![github ui for viewing commits](https://docs.github.com/assets/cb-48474/mw-1440/images/help/commits/commits-page.webp){width=50%}



## Reading and Interpreting Git Commits {#reading_commits}

Reading through git commits is one of the best ways to learn about a codebase. 

### Other Resources for this section

- [Github's git guide to commits](https://github.com/git-guides/git-commit)
- [How to Level Up Your
  Git Commit Messages](https://www.freecodecamp.org/news/how-to-write-better-git-commit-messages/) from the 'free code camp'

The central feature of most version control system is the "commit" we describe above.    And version control, at it's heart, is da system for software developers to communicate.     Understanding the motivation and context of the 'git commit' is key to interpreting a code repository.

A git commit and the associate message should communicate:

- Why are these lines of code here?  What feature does this bit of code help to implement, or which bug was fixed?
- What other code was changed, if any?   
- Who made this change so I can ask them for more information if I need to (e.g. to debug or make changes to improve the codebase)? 
- To a limited extent, why is the code structured this way?  (that is more often described in the code itself)
- If my program incorporates, imports, or otherwise depends on this code if affected by this change? That is, I depend on this codebase and something has changed that makes my system crash.   

We believe that approaching commits as communication will drive how you use git, and also help you to collaborate with github.  

### How people communicate using commit messages

What are the features of git (independent of github) to use commit messages as communication?       This is always covered in an introductory git course, and we review some of these above and chapter 2, but we summarize them here from the perspective of a communication system: 

1. the set of changes to the code.  when compare these changes to another version of the code, this is known as the "**diff**" (named for the utility that shows the changes)   
2. the commit message
3. option additional summary message
4. other things not directly part of the commit that put the commit in context: the branch it's in, the fork it's a part of, and a link to a description of the feature or issue (more on all of those things later)

#### Guidelines for using commits

These are some guidelines that software developers adhere to for using git commit

1. Keep the commit focused on a very specific problem to fix or feature to add.   Note that features often require many small adjustments or changes and so a feature implementation in code can be a collection of these.   Some use the phrase "atomic" to describe the changes you make:  the smallest amount of change to make a difference, no less and no more.  
2. could _should_ still work when commiting.  That is, don't commit unworking code unless you absolutely have to.  
3. the git commit message should focus on "why" instead of "what": the code diff already shows the what 

Some things to emphasize:  

A good commit is focused on solving a single problem or making a change that helps to implementing a small feature.   This way it's very clear was code was changed or added and why.    When we you look over all the changes in a commit, it will be hard to to get a holistic understanding if it includes many changes lines across many files.   Explorering git commit logs in github will help you to understand how to use git more effectively.   Less is more when it comes to commits.

It takes discipline to make the commits completely atomic.   We often think a change is complete,  only to find a typo or other problem after the commit is made.    Git has mechanisms for dealing with that we will define later. 

Git+github is not a backup system.    If you want to save all the work you've done use a real file back-up system, not git.    Mac and Windows both have backup systems built-in, and you should use them to make as frequent snapshots or backups as possible.    You could also have a copy of your code folder on an external drive.  

What if you are given a large set of changes that only halfway implements a bug fix or feature?  Would you understand what do to next?  that is one reason why commits should be as complete as possible.   Sometimes because of how teams agree to work you  may be encouraged to push all of your code so it can be reviewed, even if you are not finished.   In that case devs often put the acronym "*WIP*" for "*Work in Progress*" to indicate the code is not complete, or "*untested*" to indicate the code is complete but has not been rigorously tested.  


#### Examples of ineffective commits:

A change to a few lines in the readme for grammar or other minor edit, with the message "*update readme*"  - this doesn't say why the README was updated!   

A commit that says "*daily commit*" or "*end-of-day commit*" tells me nothing about why the code was changed, or how I should start up to complete it if I'm asked.    Again, this appears to be an attempt to use git+github as a backup system.   Don't do that. 

git commit message "*fix*" --  fix what and why?

#### Effective Commits

Effective commits can be 1 line of code or hundreds, it really depends on the context and what is being communicated.  

One example of a common problem in coding is the 'boundary error' or the related 'off by one' error.   for example if you are checking if a loop is done for a counter that is reduced each time, and you have `counter==0`  but some how the counter can be negative in some cases, the loop will continue!   The solution is to change your `if` condition to `counter < 1`  and a good commit message would "*fix boundary error in replication loop*"   You don't need to mention the file name - that will be in the diff.  

#### Real-world dev cycle

Being disciplined for commits is not easy and the authors frequently don't follow this.   Here is an example real-world, imperfect workflow: 

1. for example adding a feature "add logistic regression analysis"
2. add code to accomplish this (and data files, parameters, etc)
3. quick testing show that is works!
4. add changed files and commit "add log regression for X,Y, Z..."
5. test again and find there is a problem!  
6. fix the code, and test again
7. git add the files and commit "fix missing parameter for logistic regression analysis" or something like that

Now we have two diffs for one feature.  

Git has some great features for dealing with this that we will cover, and that will make you understand why everyone else's commit history looks so clean and perfect!    One major solution is to use branching, which we described above.   Branching is like telling the sub-plot in a story.   Other solutions are 'squashed' commits and amending commits.  

<!-- todo add the story of learning and then explaining directions to a new destination --> 


#### Viewing commits and diffs using github

The git hub user interface makes it very easy to explore commits and code changes.   For the workshop that this text supports, we walk through with an example.  

<!-- TODO: add links to example github commits in projects -->



#  Anatomy of a code repository {#repo-organization}

We've learn about git and github, which is how to work and communicate changes in code, but what about the code itself?   This section may help you decipher the files and folders in a code base to make use of it, regardless of where it may be.  However github makes it very easy to navigate code, and is integral to communicate what the code is for. 


## Why read the source code?

First, why would one want to be a github tourist in the first place? Let set out a few reasons you may examine or use another project's code (either via github or from some other site):

- track down a problem you are having by understanding how the code is working or has changed;
- use the code to perform a function you need, either in whole or in part;
- to learn by seeing how others have written and organized code, programming structures, or files in a project. 
- to change it, adding a feature or improve in some otherw ay 

An old phrase in open source programming to describe how to track down a problems or understand how a program works is "use the source, Luke!" 

There are dozens of blog posts explaining why reading source code is valuable. But you may be here to 
Are there other reasons? 

Resources:

-  ["Reading Code Is an Important Skill. Here’s Why. "](https://builtin.com/software-engineering-perspectives/reading-code) by Tammy Xu, builtin.com


## Understanding different types of code bases

There are many ways to categorize software but, from the perspective of open science, let's consider the axis of how we use the software.  We find that there are (at least) three identifiable categories of code bases in terms of how you would use the code and maybe interact with the code base. 

There are many other ways to categorize software (language, function, outputs, domain, style, etc etc), seeing code bases in these categories these may help you understand what kind of code base you are developing and thus organize your files and code.   

Note that the organizational principles and conventions we described are independent of whether a code base is  a 'repository' (managed by git), or pushed to github.   We use github to discover, explore and use code but it could be anywhere, or even emailed to you as a zip full of files and folders.   


### Package Codebase (installable)

These are the free and open packages we install for R, Python, Julia, Java, Rust, etc etc.  These could also be stand-alone programs written in any language, for example we use the GDAL system 

These may be called packages, libraries, binaries,extensions, etc.  

The goal of these projects is to be used by others for a general purpose.   Most of the work we do is not to create packages, but if we find that "function" (NB need a better word here) of our code is applicable to a larger class of problems than the one we are solving, it may be worth creating a package.  

As a user of such a package, you don't need to access the code via github - you can most likely install from a package system (like Pypi, R package mirror,)
All of us use package Creating an R package 


### Project Codebase (useable) 

These codebases may not be installable projects, but are intended to be re-used by someone else, and that is often your future self!   Many of these include instructions for clone the code, getting all the piece you need installed, and using the program.  

An example of this is https://github.com/billspat/hpcc_megadetector which was created for a handful of researchers at MSU to run a specific chunk of python code to identify wildlife in millions of photos.  There are already existing deep-learning model code, and an install GUI program, but nothing specific to running on MSU's super computer.  To accomplish this we forked just the pieces of code we needed from this existing system, modified it to do the work we needed, created 'wrapper scripts' that coudl run them on HPC, and added documentation.  it hasn't been used in two years not and it would require updataing to be used again.  

Another example of a 'project' repositories are specific-purpose web applications.   If your goal is to create a web application to help others use your software (rather than write a desktop application or leave it as command line only) then starting with an existing 


### Reference Codebase (readable) 

There are many reason why code is published for transparent reference rather than to be re-useable.  For one, the programming effort to create code that's usable by others  is significant, which can delay or even hinder simpling getting a computational analysis completed.   Second, many of our research or academic code is useless with out the input data, and those data sets are frequently no able to be published if they are acquired from a private source.   

Many projects use code to clean data sets in a reproducible way for use in analyses, but the configuration and setup required to keep these generic takes more time than available.    

However there are many good practices one can follow to start with code that can be re-useable by others that we will cover in a later workshop.  


## Examples by Codebase Types

### Reference: 

Here is a codebase in 'assembly language' that controlled vehicles for space travel:  [Source Code for the Apollo 11 Mission](https://github.com/chrislgarry/Apollo-11)

This is clearly for reference!  There are no computers on which this could run (unless someone creates a vitual simulator of the Apollo command module that can run) 


***Examples of some reference code became a packages**

The Geneplexux project is from MSU in the Arjun Krishnan lab and is system that creates and applies machine-learning models from gene networks to predict which novel genes may be related to a geneset one is ins=terested in.  It started as a project of code that demonstrated the basis of the system (e.g. reference code).  This lab then honed the code to be more organized and logical, and while the project was not 'installable' but had instructions downloading the code, organizing the data and running the functions in Python.   They found creating an installable package made the system much easier to use for most people.   At that point they not only organized the code into a PIP-installed package, they improved and organized the code even further.   In addition it made it easier to incorporate their codebase into a website that created a graphical interface to selecting inputs and to vizualizing the outputs.   The web application could be a separate project that 'imported' the geneplexus package, rather than integrating the code. The two project (geneplexus package and geneplexus cloud-based web application) could proceed concurrently. 

Which of these categories does the code for this book (and other books like it) fall into?   If the book is to have several authors, then it may be a reuseable project.  The project will have enough instructions to allow for 



## Implications of repository type for re-use

How you may still use code that can't be 'installed' as a package

# Finding and Using Documentation

<!-- note this replaces what is currently chapter 5 -->

## Important elements to look out for:

**The README file**.  While having a file named README is a longstanding tradition in source code, Github's innovation was to show the readme file below the code files, and to use markdown formatting to render a nice looking readme.  Now this is a core feature of github for many .  However the readme file does not have to be markdown and historically had no extension and was plain text (e.g. named `README` )

**Text Files**  Historical open source linux code bases had several documentation files, usually all upper-case and with an extension, and plain text for example `README` `INSTALL` `LICENSE`   Windows does not like to open this but they can be opened in a programming editor, or by right clicking and selecting "open with..." and picking TextEdit (Mac), Notepad (Windows).  

**doc folder** This is the obvious place to look but may be buried in the repository.   

**Binary formats** A colleague would always write his documentation using MS Word becuase he could easily format it and include screen shots as needed.  The issue is that those files are not readable on github, and they are not source code, so any changes can't be tracked, and not everyone has MS Word, or a recent version.   Even PDF while universally readable in many browsers can't be tracked.  hence most packages use some form of text to write documentation, and Markdown makes this easy.  

**generated** Packages use the techinque of creating documentation by adding it directly into the code using  special format, then running a documentation generator on it.  Typically the documentation is not directly reaable from the github repository, but the software maintainer runs a utility to generate the documentation that may or may not be kept and readable in sub-folder.   A common strategy is to put specially formatted comments (e.g. lines preceeded by `#` in Python and R, or using `/* .. */` block in C) before or inside the packages functions and files.  The documentation generator reads these comments and converts them to human-readable documentation.  

R packages use the [Roxygen2](https://roxygen2.r-lib.org) utility, started in 2011 (I don't know what happened to roxygen version 1), which is based on the [Doxygen](https://en.wikipedia.org/wiki/Doxygen) utility used for C & C++ software from 1997.  Roxygen2 can generate R help files, which are not in HTML or Markdown format so are not readable on github.  However there is yet another R pacakge (YARP) called PackageDown  can generate a whole website from a properly formatted package.   

Python packages often use the [Sphinx](https://www.sphinx-doc.org/en/master/) system for documentation 

**External websites**  given the documentation generation systems often don't output markdown, many developers opt to create documentation externally, and sometimes keep this documentation in a different github project.   For python a common place to keep documentation is the ['readthedocs'](https://docs.readthedocs.io/) service 

## Code as documentation

We hope we've already convinced you that reading source code is a good idea.   Documentation is often an after thought of scientific programmers and so your best bet is to go directly to the code to determine what it does, and hopefully that code is written clearly with informative file, funciton, and variable names.   Even if there is good documentation, the source code is the definitive way to learn what a program is actually doing.   

Like reading human language for understanding and interpretation, reading source code is a learned skill.  In both cases you get better as you see more examples and understand the contexts and cultures embedded in the symbols.   [This article](https://coderscat.com/learn-from-source-code/) from 'coderscat.com' has some great pointers for that. 

Common advice given to help understand a code base is to run it yourself.   This largely depends on the type of code (see the section on project types).  

### Code tests as are a great source of insight

We don't cover writing test code in this workshop, but you may have heard about it.  In short, in a successful code project someone will have written a set of short functions that check if the result from running the code matches what you'd expect.    They are often run before you merge or push to a repository to esure everything is working as expected.  

You don't have to know how to write these tests to be able to read and learn from them.   Most tests are in a "tests" or "test" folder.    If you look to see the commands leading up to a test you can learn how the author of the code base expects the code to be used.  

### Other items documentation how to work with the code

You may see the other following files in a repository.   Often the files are names with all caps and no extension, especially if the project has some  Unix/Linux provenance (as do many open source and research software projects).   On some systems (including github), upper case sorts before lower case, and so these files show at the top of a file listing since they are meant to be read before using the software.  

 - `LICENSE`  see the chapter on licencsing here.  This documents under what conditions you may use thse software and pull from or change the code
 - 'CONTRIBUTING` good open source projects have instructions and guidelines for contributing to a project.  This is very valuable for your own projects as they are instructions for your colleagues who may contribute code, or to your future self when you forget how you get everything setup!  
 - 'man' directory this is short for 'manual' and comes from Unix/Linux system called 'man pages' which I guess is for the manual as a collection of help files. 


## Versioning and releases

### Forks

## Using someone elses code

### Dependencies/requirements

### Interaction of source scripts 

# Collaboration (ch 4)

# Collaborating with GitHub {#collaborating}



<!-- keep this in ch. 4 -->

## Project management with GitHub
Using Github's project management lite features

## Issue management
What is issue management? 
Following issues and their fixes can help you track down your bugs 

### Pandas Example: 
* [My commit](https://github.com/krishnanlab/geneplexus_app/commit/80256c10d65f22fdd63898225948e36d4d63d29b)  
* [Found someone else that had the same problem](https://github.com/pandas-dev/pandas/issues/8206) 
* [Found this in the source-code for the documentation](https://github.com/pandas-dev/pandas/blob/bdc79c146c2e32f2cab629be240f01658cfb6cc2/pandas/core/generic.py#L3888)
* [This is mentioned in the release notes for verion 1.5.0](https://pandas.pydata.org/pandas-docs/version/1.5/whatsnew/v1.5.0.html#other-deprecations)
  + The release notes have a link to the issue(s) for every change, including this one GH9568 , which spells out why the change was made.
* Since I didn't even need to specify this parameter (it was using the default value!) I just removed it from my code, and learned my lesson to keep my code as simple as possible so that I don't get burned by changes into the packages I depend upon.   


## Communication using issues 

### Requesting help/features or reporting bugs (using reprexes).  

### Example: How ask package maintainers to accommodate the global dateline and very high latitudes 
* https://github.com/rstudio/leaflet/issues/495
  + This is a great example of an obtuse issue.  There is an R package "MapView" this is a 1-stop-mapping thing, super easy.  Someone there raised an issue.   MapView depends on RLeaflet (I just know this, it doesn't say that anywhere in the issue).  The leader of the MapView project realized that it was an RLeaflet problem, so copy/pasted the issue into the RLeaflet project.  I say RLeaflet because that project actually heavily depends on the original leaflet.js for javascript, which most people just called "leaflet". Another interesting thing is that the first commenter (Darcy somebody) says that polygons are fine, which does not need to be said because the OP already said it was ok, but no one piled on and said "he already said that." Note the issue was raised in 2015 and no one was assigned and it was not fixed.   The issue was reference in 2018 for new issue (created by Rstudio) to fix it, and I only know that because in the new issue they referenced the issue number.    but even that one was not fixed.   also in the original issue is an extensive post to show a work-around.  That info now just =sits here in a github issue.    A question for the group: what should have been done by the project to deal with this issue (hints, create an issue to add the work-around in the documentation, when creating a new issue, close the original and reference the new one..  possibly tag it as "wontfix" or better tag it in a project roadmap to make it clear they care about it and will deal with at some future time.
* https://github.com/rstudio/leaflet/issues/225

### Example: ggmap package
Issue with Pacific mapping with ggmap: https://github.com/dkahle/ggmap/issues/326 
* (solution is to change the projection, the software is not the problem, but is it in the docs?)
* Another person had a question/problem but it was totally ignored: https://github.com/dkahle/ggmap/issues/295  
  + Why is that?  
  + Is there a document for this package describing how to participate in the community?  
  + Are the volunteers following the lead of the owner?
  + Who is fine ignoring these?

<!-- create a new chapter for this topic -->

# Engaging with the community 

Engaging with owners/maintainers and the broader coding community to identify and participate in discussion of issues. 


<!-- move this to to Ch. 3 Tour of Github -->

## What is a 'pull request?' (PR) (hint: it's a github thing)
* A PR lifecycle: 
  + Issue
  + Fork/Branch
  + PR
  + Merge

## Github link awesomeness
* Permalinks in code and issues
* References to issues from commits and referencing to commits from comments




you can say "here is problem" or you can ask "is this a problem?"  but a PR instead changes  the conversatin to  "is this a solution?" which is more efficient



in excercise, give them several things to be 1) making branch and editing 2) creating PR 3) forking 4) adding a comment ot the code, issue or merge request









